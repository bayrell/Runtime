/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.Context;
use Runtime.Map;
use Runtime.rs;
use Runtime.rtl;
use Runtime.Vector;
use Runtime.Interfaces.ContextInterface;
use Runtime.Interfaces.FactoryInterface;
use Runtime.Interfaces.SerializeInterface;


#switch
#case ifcode JAVASCRIPT then
var isBrowser=function(){return typeof window !== "undefined" && this === window;}
#endswitch


export class RuntimeUtils{
	
	
	
	/* ================================ Context Functions ================================ */
	
	
	protected static var _global_context = null;
	
	
	/**
	 * Returns global context
	 * @return ContextInterface
	 */
	public static ContextInterface getContext()
	{
		#switch
		#case ifcode PHP then
		return self::$_global_context;
		#case ifcode NODEJS then
		return RuntimeUtils._global_context;
		#case ifcode ES6 then
		return Runtime.RuntimeUtils._global_context;
		#endswitch
	}
	
	
	
	/**
	 * Set global context
	 * @param ContextInterface context
	 */
	public static ContextInterface setContext(ContextInterface context)
	{
		#switch
		#case ifcode PHP then
		self::$_global_context = $context;
		#case ifcode JAVASCRIPT then
		if (isBrowser()) Runtime.RuntimeUtils._global_context = context;
		else RuntimeUtils._global_context = context;
		#endswitch
		return context;
	}
	
	
	
	/**
	 * Register global Context
	 */
	public static ContextInterface createContext(Vector<string> modules = null)
	{
		ContextInterface context = new Context();
		if (modules != null){
			modules.each(
				void (string module) use (context){
				context.registerModule(module);
				}
			);
		}
		return context;
	}
	
	
	
	/**
	 * Register global Context
	 */
	public static ContextInterface registerGlobalContext(Vector<string> modules = null)
	{
		ContextInterface context = self::createContext(modules);
		context.init();
		self::setContext(context);
		return context;
	}
	
	
	
	/* ========================== Class Introspection Functions ========================== */
	
	
	/**
	 * Returns parents class names
	 * @return Vector<string>
	 */
	public static Vector<string> getParents(string class_name)
	{
		Vector<string> res = new Vector();
		
		while (class_name != "")
		{
			class_name = rtl::callStaticMethod(class_name, "getParentClassName");
			if (class_name != "")
			{
				res.push(class_name);
			}
		}
		
		return res;
	}
	
	
	
	/**
	 * Returns true if class exists
	 * @return Vector<string>
	 */
	declare public static Vector<string> getInterfaces(string class_name);
	
	#switch
	#case ifcode PHP then
	static function getInterfaces($class_name){
		$arr = array_values(class_implements(rtl::find_class($class_name)));
		$v = (new Vector())->_assignArr($arr);
		$v = $v->map(function ($s){
			return str_replace("\\", ".", $s);
		});
		return $v;
	}
	#case ifcode JAVASCRIPT then
	static getInterfaces(class_name){
		return new Vector();
	}
	#endswitch
	
	
	
	/**
	 * Returns names of variables to serialization
	 * @param Vector<string>
	 */
	public static void getVariablesNames(string class_name, Vector<string> names)
	{
		Vector<string> classes = self::getParents(class_name);
		classes.prepend(class_name);
		classes.each(
			void (string class_name) use (names)
			{
				try{ rtl::callStaticMethod(class_name, "getFieldsList", [names]); } catch (var e) {}
				try{ rtl::callStaticMethod(class_name, "getVirtualFieldsList", [names]); } catch (var e) {}
			}
		);
		names.removeDublicates();
	}
	
	
	
	/**
	 * Returns Introspection of the class name
	 * @param string class_name
	 * @return Vector<IntrospectionInfo>
	 */
	static Vector<IntrospectionInfo> getIntrospection(string class_name)
	{
		Vector<IntrospectionInfo> res = new Vector();
		Vector<string> class_names = self::getParents(class_name);
		class_names.prepend(class_name);
		
		class_names.each(
			void (string item_class_name) use (res)
			{
				Vector<string> names = new Vector();
				
				
				/* Get fields introspection */
				try{ rtl::callStaticMethod(item_class_name, "getFieldsList", [names]); } catch (var e) {}
				names.each(
					void (string field_name) use (res, item_class_name)
					{
						IntrospectionInfo info = null;
						try
						{ 
							info = rtl::callStaticMethod(item_class_name, "getFieldInfoByName", [field_name]);
						}
						catch (var e) { info = null; }
						
						if (info != null)
						{
							info.class_name = item_class_name;
							res.push(info);
						}
					}
				);
				
				
				/* Get virtual fields introspection */
				names.clear();
				try{ rtl::callStaticMethod(item_class_name, "getVirtualFieldsList", [names]); } catch (var e) {}
				names.each(
					void (string field_name) use (res, item_class_name)
					{
						IntrospectionInfo info = null;
						try
						{ 
							info = rtl::callStaticMethod(item_class_name, "getVirtualFieldInfo", [field_name]);
						}
						catch (var e) { info = null; }
						
						if (info != null)
						{
							info.class_name = item_class_name;
							res.push(info);
						}
					}
				);
				
				
				/* Get methods introspection */
				names.clear();
				try{ rtl::callStaticMethod(item_class_name, "getMethodsList", [names]); } catch (var e) {}
				names.each(
					void (string method_name) use (res, item_class_name)
					{
						IntrospectionInfo info = null;
						try
						{ 
							info = rtl::callStaticMethod(item_class_name, "getMethodInfoByName", [method_name]);
						}
						catch (var e) { info = null; }
						
						if (info != null)
						{
							info.class_name = item_class_name;
							res.push(info);
						}
					}
				);
				
				
				/* Get class introspection */
				try
				{ 
					info = rtl::callStaticMethod(item_class_name, "getClassInfo", []);
				}
				catch (var e) { info = null; }
				if (info != null)
				{
					info.class_name = item_class_name;
					res.push(info);
				}
				
			}
		);
		
		return res;
	}
	
	
	
	
	/* ============================= Serialization Functions ============================= */
	
	
	static var ObjectToNative(var value, bool force_class_name = false){
		value = self::ObjectToPrimitive(value, force_class_name);
		value = self::PrimitiveToNative(value);
		return value;
	}
	static var NativeToObject(var value){
		value = self::NativeToPrimitive(value);
		value = self::PrimitiveToObject(value);
		return value;
	}
	
	
	
	/**
	 * Returns object to primitive value
	 * @param mixed obj
	 * @return mixed
	 */
	public static mixed ObjectToPrimitive(mixed obj, bool force_class_name = false){
	
		if (obj === null) return null;
		if (rtl::isScalarValue(obj)) return obj;
		
		if (obj instanceof Vector)
		{
			Vector<mixed> res = new Vector();
			for (int i=0; i<obj.count(); i++)
			{
				mixed value = obj.item(i);
				value = self::ObjectToPrimitive( value, force_class_name );
				res.push(value);
			}
			return res;
		}
		
		if (obj instanceof Map)
		{
			Map<mixed> res = new Map();
			Vector<string> keys = obj.keys();
		
			for (int i=0; i<keys.count(); i++)
			{
				string key = keys.item(i);
				mixed value = obj.item(key);
				value = self::ObjectToPrimitive( value, force_class_name );
				res.set(key, value);
			}
			
			delete keys;
			if (force_class_name){
				res.set("__class_name__", classof Map);
			}
			
			return res;
		}
		
		
		if (obj implements SerializeInterface){
			
			Vector<string> names = new Vector();
			Map<string, mixed> values = new Map();
			obj.getVariablesNames(names);
			
			for (int i=0; i<names.count(); i++)
			{
				string variable_name = names.item(i);
				var value = obj.takeValue(variable_name, null);
				var value = self::ObjectToPrimitive( value, force_class_name );
				values.set(variable_name, value);
			}
			
			values.set("__class_name__", obj.getClassName());
			delete names;
			
			return values;
		}
		
		return null;
	}
	
	
	
	/**
	 * Returns object to primitive value
	 * @param SerializeContainer container
	 * @return mixed
	 */
	public static mixed PrimitiveToObject(mixed obj){
		
		if (obj === null) return null;
		if (rtl::isScalarValue(obj)) return obj;
		
		if (obj instanceof Vector)
		{
			Vector<mixed> res = new Vector();
			for (int i=0; i<obj.count(); i++)
			{
				mixed value = obj.item(i);
				value = self::PrimitiveToObject(value);
				res.push(value);
			}
			return res;
		}
		
		if (obj instanceof Map)
		{
			Map<mixed> res = new Map();
			Vector<string> keys = obj.keys();
		
			for (int i=0; i<keys.count(); i++)
			{
				string key = keys.item(i);
				mixed value = obj.item(key);
				value = self::PrimitiveToObject(value);
				res.set(key, value);
			}
			
			delete keys;
			
			if ( !res.has("__class_name__") ) return res;
			if ( res.item("__class_name__") == "Runtime.Map" ){
				res.remove("__class_name__");
				return res;
			}
			
			string class_name = res.item("__class_name__");
			if (not rtl::class_exists(class_name)){
				return null;
			}
			if (not rtl::class_implements(class_name, "Runtime.Interfaces.SerializeInterface")){
				return null;
			}
			
			/* New instance */
			SerializeInterface instance = rtl::newInstance(class_name, null);
			
			/* Assign values */
			Vector<string> names = new Vector();
			instance.getVariablesNames(names);
			for (int i=0; i<names.count(); i++)
			{
				string variable_name = names.item(i);
				if (variable_name != "__class_name__") 
				{
					var value = res.get(variable_name, null);
					instance.assignValue(variable_name, value);
				}
			}
			
			delete res;
			
			return instance;
		}
		
		return null;
	}
	
	
	
	#switch
	#case ifcode PHP then
	
	static function NativeToPrimitive($value){
		if ($value === null)
			return null;
			
		if (is_object($value)){
			$res = new \Runtime\Map($value);
			$res = $res->map(function ($key, $val){
				return self::NativeToPrimitive($val);
			});
			return $res;
		}
		
		if (is_array($value)){
			if ( isset($value['__class_name__']) ){
				$res = new \Runtime\Map($value);
				$res = $res->map(function ($key, $val){
					return self::NativeToPrimitive($val);
				});
				return $res;
			}
			$arr = array_values($value);
			$res = (new \Runtime\Vector())->_assignArr($arr);
			$res = $res->map(function ($item){
				return self::NativeToPrimitive($item);
			});
			return $res;
		}
		
		return $value;
	}
	
	#case ifcode JAVASCRIPT then
	static NativeToPrimitive(value){
		
		var _rtl = null; if (isBrowser()) _rtl=Runtime.rtl; else _rtl=rtl;
		var _Utils = null; if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=RuntimeUtils;
		var _Vector=null; if (isBrowser()) _Vector=Runtime.Vector; else _Vector=Vector;
		var _Map=null; if (isBrowser()) _Map=Runtime.Map; else _Map=Map;
		
		if (value === null)
			return null;
		
		if (Array.isArray(value)){
			var new_value = (new _Vector()).concat(value);
			new_value = new_value.map((val)=>{
				return _Utils.NativeToPrimitive(val);
			});
			return new_value;
		}
		if (typeof value == 'object'){
			var new_value = new _Map(value);
			new_value = new_value.map((key, val)=>{
				return _Utils.NativeToPrimitive(val);
			});
			return new_value;
		}
		
		return value;
	}
	static PrimitiveToNative(value){
		
		var _rtl = null; if (isBrowser()) _rtl=Runtime.rtl; else _rtl=rtl;
		var _Utils = null; if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=Utils;
		var _Vector=null; if (isBrowser()) _Vector=Runtime.Vector; else _Vector=Vector;
		var _Map=null; if (isBrowser()) _Map=Runtime.Map; else _Map=Map;
		
		if (value === null)
			return null;
		
		if (value instanceof _Vector){
			var arr = [];
			value.each((v)=>{
				arr.push( _Utils.PrimitiveToNative(v) );
			});
			return arr;
		}
		if (value instanceof _Map){
			var obj = {};
			value.each((k, v)=>{
				obj[k] = _Utils.PrimitiveToNative(v);
			});
			return obj;
		}
		
		return value;
	}
	#endswitch
	
	
	
	
	const int JSON_PRETTY = 1;
	
	
	/**
	 * Json encode serializable values
	 * @param serializable value
	 * @param SerializeContainer container
	 * @return string 
	 */
	declare export static string json_encode(mixed value, int flags = 0, bool convert = true);

	#switch
	#case ifcode PHP then
	static function json_encode($value, $flags = 0, $convert = true){
		if ($convert){
			$value = self::ObjectToPrimitive($value);
		}
		$json_flags = JSON_UNESCAPED_UNICODE;
		if ( ($flags & 1) == 1 ) $json_flags = $json_flags | JSON_PRETTY_PRINT;
		return json_encode($value, $json_flags);
	}
	#case ifcode JAVASCRIPT then
	static json_encode(value, flags, convert){
		if (flags == undefined) flags = 0;
		if (convert == undefined) convert = true;
		var _Utils=null;if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=RuntimeUtils;
		var _Vector=null;if (isBrowser()) _Vector=Runtime.Vector; else _Vector=Vector;
		var _Map=null;if (isBrowser()) _Map=Runtime.Map; else _Map=Map;
		var _rtl=null;if (isBrowser()) _rtl=Runtime.rtl; else _rtl=rtl;
		if (convert) value = _Utils.ObjectToPrimitive(value);
		return JSON.stringify(value, function (key, value){
			if (_rtl.isScalarValue(value)) return value;
			if (value instanceof _Vector) return value;
			if (value instanceof _Map) return value.toObject();
			return undefined;
		});
	}
	#endswitch
	
	
	
	/**
	 * Json decode to primitive values
	 * @param string s Encoded string
	 * @return mixed 
	 */
	declare export static mixed json_decode(string s);

	#switch
	#case ifcode PHP then
	static function json_decode($obj){
		$res = @json_decode($obj, false);
		if (!$res)
			return null;
		return self::NativeToObject($res);
	}
	#case ifcode JAVASCRIPT then
	static json_decode(s, context){
		try{
			var _Utils=null;if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=RuntimeUtils;
			var _Vector=null;if (isBrowser()) _Vector=Runtime.Vector; else _Vector=Vector;
			var _Map=null;if (isBrowser()) _Map=Runtime.Map; else _Map=Map;			
			var obj = JSON.parse(s, function (key, value){
				if (Array.isArray(value)){
					return new _Vector(value);
				}
				if (typeof value == 'object'){
					return new _Map(value);
				}
				
				return value;
			});
			return _Utils.PrimitiveToObject(obj);
		}
		catch(e){
			return null;
		}
	}
	#endswitch
	
	
	/**
	 * Base64 encode
	 * @param string s
	 * @return string 
	 */
	declare export static string base64_encode(string s);
	
	#switch
	#case ifcode PHP then
	static function base64_encode($s){
		return base64_encode($s);
	}
	#case ifcode ES6 then
	static base64_encode(s){
		return window.btoa($s);
	}
	#case ifcode NODEJS then
	static base64_encode(s){
		return Buffer.from(s).toString('base64');
	}
	#endswitch
	
	
	/**
	 * Base64 decode
	 * @param string s
	 * @return string 
	 */
	declare export static string base64_decode(string s);
	
	#switch
	#case ifcode PHP then
	static function base64_decode($s){
		return base64_decode($s);
	}
	#case ifcode ES6 then
	static base64_decode(s){
		return window.atob($s);
	}
	#case ifcode NODEJS then
	static base64_decode(s){
		return Buffer.from(s, 'base64').toString('ascii');
	}
	#endswitch
	
	
	

	/* ================================= Other Functions ================================= */
	
	
	
	/*
	 * Generate password
	 *
	 * @param int length The lenght of the password
	 * @param string options What kinds of the char can be in password
	 *   a - lower case chars
	 *   b - upper case chars
	 *   c - numbers
	 *   d - special chars !@#$%^&?*_-+=~(){}[]<>|/,.:;\\
	 *   e - quotes `"'
	 */	
	public static string randomString(int length=16, string options="abc"){
		string s = "";
		if (rs::strpos(options, "a") >= 0) s ~= "abcdefghjkmnpqrstuvwxyz";
		if (rs::strpos(options, "b") >= 0) s ~= "ABCDEFGHJKMNPQRSTUVWXYZ";
		if (rs::strpos(options, "c") >= 0) s ~= "1234567890";
		if (rs::strpos(options, "d") >= 0) s ~= "!@#$%^&?*_-+=~(){}[]<>|/,.:;\\";
		if (rs::strpos(options, "e") >= 0) s ~= "`\"\'";
		string res = "";
		int c = rs::strlen(s);
		for (int i=0; i<length; i++){
			int k = rtl::random(0, c-1);
			res ~= s[k];
		}
		return res;
	}
	
	
	/**
	 * Returns true if value is primitive value
	 * @return boolean 
	 */
	public static bool isPrimitiveValue(var value)
	{
		if (rtl::isScalarValue(value)) return true;
		if (value instanceof Vector) return true;
		if (value instanceof Map) return true;
		return false;
	}
	
	
	
	/**
	 * Convert bytes to string
	 * @param Vector<byte> arr - vector of the bytes
	 * @string charset - charset of the bytes vector. Default utf8
	 * @return string
	 */
	public string bytesToString(Vector<byte> arr, string charset="utf8"){}
	
	
	
	/**
	 * Convert string to bytes
	 * @param string s - incoming string
	 * @param Vector<byte> arr - output vector
	 * @param charset - Result bytes charset. Default utf8
	 */
	public void stringToBytes(string s, Vector<byte> arr, string charset="utf8"){}
	
	
	
	/**
	 * Translate message
	 * @params string message - message need to be translated
	 * @params MapInterface params - Messages params. Default null.
	 * @params string locale - Different locale. Default "".
	 * @return string - translated string
	 */
	public static string translate(
		string message, MapInterface params = null, string locale = "", 
		Object context = null
	){
		if (context == null) context = self::globalContext();
		if (context != null) {
			Vector<var> args = (new Vector<var>())
				.push(message)
				.push(params)
				.push(locale)
			;
			return rtl::callMethod(
				context,
				"translate",
				args
			);
		}	
		return message;
	}
	
}