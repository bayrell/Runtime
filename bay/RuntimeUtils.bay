/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.Collection;
use Runtime.Context;
use Runtime.CoreStruct;
use Runtime.Dict;
use Runtime.Map;
use Runtime.rs;
use Runtime.rtl;
use Runtime.UIStruct;
use Runtime.Vector;
use Runtime.Annotations.IntrospectionClass;
use Runtime.Annotations.IntrospectionInfo;
use Runtime.Interfaces.SerializeInterface;


#switch
#case ifcode JAVASCRIPT then
var isBrowser=function(){return typeof window !== "undefined" && this === window;}
#endswitch


static class RuntimeUtils
{
	
	
	
	/* ================================ Context Functions ================================ */
	
	
	protected static var _global_context = null;
	protected static Map _variables_names = null;
	
	
	/**
	 * Returns global context
	 * @return Context
	 */
	public static Context @getContext()
	{
		#switch
		#case ifcode PHP then
		return self::$_global_context;
		#case ifcode NODEJS then
		return RuntimeUtils._global_context;
		#case ifcode ES6 then
		return Runtime.RuntimeUtils._global_context;
		#endswitch
	}
	
	
	
	/**
	 * Set global context
	 * @param Context context
	 */
	public static Context @setContext(Context context)
	{
		#switch
		#case ifcode PHP then
		self::$_global_context = $context;
		#case ifcode JAVASCRIPT then
		/*if (isBrowser()) Runtime.RuntimeUtils._global_context = context;
		else RuntimeUtils._global_context = context;*/
		use("Runtime.RuntimeUtils")._global_context = context;
		#endswitch
		return context;
	}
	
	
	
	/* ========================== Class Introspection Functions ========================== */
	
	
	/**
	 * Returns parents class names
	 * @return Vector<string>
	 */
	static Collection<string> getParents(string class_name)
	{
		Vector<string> res = new Vector();
		res.push(class_name);
		
		while (class_name != "")
		{
			var f = rtl::method(class_name, "getParentClassName");
			class_name = f();
			if (class_name != "")
			{
				res.push(class_name);
			}
		}
		
		return res.toCollection();
	}
	
	
	
	/**
	 * Returns Introspection of the class name
	 * @param string class_name
	 * @return Vector<IntrospectionInfo>
	 */
	lambda memorize Collection<string> getVariablesNames(string class_name, int flag = 2)
	{
		/* Get parents names */
		Collection<string> class_names = self::getParents(class_name);
		
		Vector<string> names = class_names.reduce
		(
			Vector<string> (Vector<string> names, string item_class_name) use (flag)
			{
				Collection<string> item_fields = null;
				fn f = rtl::method(item_class_name, "getFieldsList");
				try { item_fields = f(flag); } catch (var e) {}
				if (item_fields != null)
				{
					names.appendVector(item_fields);
				}
				return names;
			},
			new Vector()
		);
		
		return names.toCollection();
	}
	
	
	
	/**
	 * Returns Introspection of the class name
	 * @param string class_name
	 * @return Vector<IntrospectionInfo>
	 */
	lambda memorize IntrospectionClass getClassIntrospection(string class_name)
	{
		Collection<CoreStruct> class_info = null;
		Map<Collection> fields = new Map();
		Map<Collection> methods = new Map();
		IntrospectionInfo info = null;
		
		if (not rtl::class_exists(class_name)) return null;
		
		/* Append annotations */
		fn appendAnnotations = void (Map<Collection> arr, string name, IntrospectionInfo info)
		{
			if (info == null) return;
			if (not arr.has(name)) arr.set(name, new Vector());
			Vector v = arr.item(name);
			v.appendVector(info.annotations);
		};
		
		/* Get Class Info */
		try
		{ 
			info = rtl::method(class_name, "getClassInfo")();
			if (info != null) class_info = info.annotations;
		}
		catch (var e){}
		
		/* Get parents names */
		Collection<string> class_names = self::getParents(class_name);
		for (int i=0; i<class_names.count(); i++)
		{
			string item_class_name = class_names.item(i);
			
			/* Get fields introspection */
			Collection<string> item_fields = null;
			try { item_fields = rtl::method(item_class_name, "getFieldsList")(3); } catch (var e) {}
			for (int j=0; j<item_fields.count(); j++)
			{
				string field_name = item_fields.item(j);
				info = rtl::method(item_class_name, "getFieldInfoByName")(field_name);
				appendAnnotations(fields, field_name, info);
			}
			
			/* Get methods introspection */
			Collection<string> item_methods = null;
			try { item_methods = rtl::method(item_class_name, "getMethodsList")(); } catch (var e) {}
			for (int j=0; j<item_methods.count(); j++)
			{
				string method_name = item_methods.item(j);
				info = rtl::method(item_class_name, "getMethodInfoByName")(method_name);
				appendAnnotations(methods, method_name, info);
			}
		}
		
		/* To Collection */
		methods = methods.map(Collection (Vector item, string name) => item.toCollection());
		fields = fields.map(Collection (Vector item, string name) => item.toCollection());
		
		return new IntrospectionClass
		{
			"class_name": class_name,
			"class_info": (class_info != null) ? class_info.toCollection() : null,
			"fields": fields.toDict(),
			"methods": methods.toDict(),
			"interfaces": rtl::getInterfaces(class_name),
		};
	}
	
	
	
	/* ============================= Serialization Functions ============================= */
	
	
	static var ObjectToNative(var value, bool force_class_name = false){
		value = self::ObjectToPrimitive(value, force_class_name);
		value = self::PrimitiveToNative(value);
		return value;
	}
	static var NativeToObject(var value){
		value = self::NativeToPrimitive(value);
		value = self::PrimitiveToObject(value);
		return value;
	}
	
	
	
	/**
	 * Returns object to primitive value
	 * @param var obj
	 * @return var
	 */
	public static var ObjectToPrimitive(var obj, bool force_class_name = false){
	
		if (obj === null) return null;
		if (rtl::isScalarValue(obj)) return obj;
		
		if (obj instanceof Collection)
		{
			return obj.map(
				var (var value) use (force_class_name)
				{
					return static::ObjectToPrimitive( value, force_class_name );
				}
			);
			
			/*
			Vector<var> res = new Vector();
			for (int i=0; i<obj.count(); i++)
			{
				var value = obj.item(i);
				value = self::ObjectToPrimitive( value, force_class_name );
				res.push(value);
			}
			return res.toCollection();
			*/
		}
		
		if (obj instanceof Dict)
		{
			
			obj = obj.map(
				var (string key, var value) use (force_class_name)
				{
					return static::ObjectToPrimitive( value, force_class_name );
				}
			);
			
			/*
			Map<var> res = new Map();
			Vector<string> keys = obj.keys();
			
			for (int i=0; i<keys.count(); i++)
			{
				string key = keys.item(i);
				var value = obj.item(key);
				value = self::ObjectToPrimitive( value, force_class_name );
				res.set(key, value);
			}
			
			delete keys;
			*/
			if (force_class_name){
				obj = obj.setIm("__class_name__", classof Dict);
			}
			
			return obj.toDict();
		}
		
		
		if (obj implements SerializeInterface)
		{
			Map<var> values = new Map();
			Collection<string> names = static::getVariablesNames(obj.getClassName(), 1);
			
			for (int i=0; i<names.count(); i++)
			{
				string variable_name = names.item(i);
				var value = obj.takeValue(variable_name, null);
				var value = self::ObjectToPrimitive( value, force_class_name );
				values.set(variable_name, value);
			}
			
			values.set("__class_name__", obj.getClassName());
			delete names;
			
			return values.toDict();
		}
		
		return null;
	}
	
	
	
	/**
	 * Returns object to primitive value
	 * @param SerializeContainer container
	 * @return var
	 */
	public static var PrimitiveToObject(var obj)
	{
		
		if (obj === null) return null;
		if (rtl::isScalarValue(obj)) return obj;
		
		if (obj instanceof Collection)
		{
			Vector<var> res = new Vector();
			for (int i=0; i<obj.count(); i++)
			{
				var value = obj.item(i);
				value = self::PrimitiveToObject(value);
				res.push(value);
			}
			return res.toCollection();
		}
		
		if (obj instanceof Dict)
		{
			Map<var> res = new Map();
			Vector<string> keys = obj.keys();
		
			for (int i=0; i<keys.count(); i++)
			{
				string key = keys.item(i);
				var value = obj.item(key);
				value = self::PrimitiveToObject(value);
				res.set(key, value);
			}
			
			delete keys;
			
			if ( !res.has("__class_name__") ) return res;
			if ( res.item("__class_name__") == "Runtime.Map" or res.item("__class_name__") == "Runtime.Dict" )
			{
				res.remove("__class_name__");
				return res.toDict();
			}
			
			string class_name = res.item("__class_name__");
			if (not rtl::class_exists(class_name))
			{
				return null;
			}
			if (not rtl::class_implements(class_name, "Runtime.Interfaces.SerializeInterface"))
			{
				return null;
			}
			
			/* New instance */
			SerializeInterface instance = rtl::newInstance(class_name, null);
			
			/* Assign values */
			Map<var> obj = new Map();
			Collection<string> names = static::getVariablesNames(class_name, 1);
			for (int i=0; i<names.count(); i++)
			{
				string variable_name = names.item(i);
				if (variable_name != "__class_name__") 
				{
					var value = res.get(variable_name, null);
					obj.set(variable_name, value);
					instance.assignValue(variable_name, value);
				}
			}
			if (instance instanceof CoreStruct)
			{
				instance.initData(null, obj);
			}
			
			delete res;
			
			return instance;
		}
		
		return null;
	}
	
	
	static var NativeToPrimitive(var value)
	{
		#switch
		#case ifcode PHP then
		
		if ($value === null)
			return null;
			
		if (is_object($value)){
			$res = new \Runtime\Map($value);
			$res = $res->map($ctx, function ($ctx, $val, $key){
				return self::NativeToPrimitive($ctx, $val);
			});
			return $res;
		}
		
		if (is_array($value)){
			if ( isset($value['__class_name__']) ){
				$res = new \Runtime\Map($value);
				$res = $res->map($ctx, function ($ctx, $val, $key){
					return self::NativeToPrimitive($ctx, $val);
				});
				return $res;
			}
			$arr = array_values($value);
			$res = \Runtime\Vector::from($arr);
			$res = $res->map($ctx, function ($ctx, $item){
				return self::NativeToPrimitive($ctx, $item);
			});
			return $res;
		}
		
		return $value;
	
		#case ifcode JAVASCRIPT then
		
		/*var _rtl = null; if (isBrowser()) _rtl=Runtime.rtl; else _rtl=rtl;
		var _Utils = null; if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=RuntimeUtils;
		var _Vector=null; if (isBrowser()) _Vector=Runtime.Vector; else _Vector=Vector;
		var _Map=null; if (isBrowser()) _Map=Runtime.Map; else _Map=Map;*/
		
		var _rtl = use("Runtime.rtl");
		var _Utils = use("Runtime.RuntimeUtils");
		var _Vector = use("Runtime.Vector");
		var _Map = use("Runtime.Map");
		
		if (value === null)
			return null;
		
		if (Array.isArray(value)){
			var new_value = (new _Vector()).concat(value);
			new_value = new_value.map(ctx, (ctx, val)=>{
				return _Utils.NativeToPrimitive(ctx, val);
			});
			return new_value;
		}
		if (typeof value == 'object'){
			var new_value = new _Map(value);
			new_value = new_value.map(ctx, (ctx, val, key)=>{
				return _Utils.NativeToPrimitive(ctx, val);
			});
			return new_value;
		}
		
		return value;
		#endswitch
	}
	
	static var PrimitiveToNative(var value)
	{
		
		#switch
		#case ifcode JAVASCRIPT then
		
		/*var _rtl = null; if (isBrowser()) _rtl=Runtime.rtl; else _rtl=rtl;
		var _Utils = null; if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=Utils;
		var _Collection=null; if (isBrowser()) _Collection=Runtime.Collection; else _Collection=Collection;
		var _Dict=null; if (isBrowser()) _Dict=Runtime.Dict; else _Dict=Dict;*/
		
		var _rtl = use("Runtime.rtl");
		var _Utils = use("Runtime.RuntimeUtils");
		var _Collection = use("Runtime.Collection");
		var _Dict = use("Runtime.Dict");
		
		if (value === null)
			return null;
		
		if (value instanceof _Collection){
			var arr = [];
			value.each((v)=>{
				arr.push( _Utils.PrimitiveToNative(v) );
			});
			return arr;
		}
		if (value instanceof _Dict){
			var obj = {};
			value.each((k, v)=>{
				obj[k] = _Utils.PrimitiveToNative(v);
			});
			return obj;
		}
		
		return value;
		
		#endswitch
	}
	
	
	
	static const int JSON_PRETTY = 1;
	
	
	/**
	 * Json encode serializable values
	 * @param serializable value
	 * @param SerializeContainer container
	 * @return string 
	 */
	static string json_encode(var value, int flags = 0, bool convert = true)
	{
		#switch
		#case ifcode PHP then
		if ($convert){
			$value = self::ObjectToPrimitive($ctx, $value);
		}
		$json_flags = JSON_UNESCAPED_UNICODE;
		if ( ($flags & 1) == 1 ) $json_flags = $json_flags | JSON_PRETTY_PRINT;
		return json_encode($value, $json_flags);
		
		#case ifcode JAVASCRIPT then
		if (flags == undefined) flags = 0;
		if (convert == undefined) convert = true;
		/*
		var _Utils=null;if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=RuntimeUtils;
		var _Collection=null;if (isBrowser()) _Collection=Runtime.Collection; else _Collection=Collection;
		var _Dict=null;if (isBrowser()) _Dict=Runtime.Dict; else _Dict=Dict;
		var _rtl=null;if (isBrowser()) _rtl=Runtime.rtl; else _rtl=rtl;
		*/
		
		var _rtl = use("Runtime.rtl");
		var _Utils = use("Runtime.RuntimeUtils");
		var _Collection = use("Runtime.Collection");
		var _Dict = use("Runtime.Dict");
		
		if (convert) value = _Utils.ObjectToPrimitive(ctx, value);
		return JSON.stringify(value, function (key, value){
			if (_rtl.isScalarValue(value)) return value;
			if (value instanceof _Collection) return value;
			if (value instanceof _Dict) return value.toObject();
			return null;
		});
		#endswitch
	}
	
	
	
	/**
	 * Json decode to primitive values
	 * @param string s Encoded string
	 * @return var 
	 */
	static var json_decode(var obj)
	{
		#switch
		#case ifcode PHP then
	
		$res = @json_decode($obj, false);
		if ($res === null || $res === false)
			return null;
		return self::NativeToObject($ctx, $res);
	
		#case ifcode JAVASCRIPT then
		try{
			/*
			var _Utils=null;if (isBrowser()) _Utils=Runtime.RuntimeUtils; else _Utils=RuntimeUtils;
			var _Vector=null;if (isBrowser()) _Vector=Runtime.Vector; else _Vector=Vector;
			var _Map=null;if (isBrowser()) _Map=Runtime.Map; else _Map=Map;	
			*/
			
			var _rtl = use("Runtime.rtl");
			var _Utils = use("Runtime.RuntimeUtils");
			var _Collection = use("Runtime.Collection");
			var _Dict = use("Runtime.Dict");
			
			var obj = JSON.parse(obj, function (key, value){
				if (value == null) return value;
				if (Array.isArray(value)){
					return _Collection.from(value);
				}
				if (typeof value == 'object'){
					return _Dict.from(value);
				}
				return value;
			});
			return _Utils.PrimitiveToObject(ctx, obj);
		}
		catch(e){
			throw e;
		}
		return null;
		#endswitch
	}
	
	
	
	/**
	 * Base64 encode
	 * @param string s
	 * @return string 
	 */
	static string base64_encode(string s)
	{
		#switch
		#case ifcode PHP then
		return base64_encode($s);
		#case ifcode ES6 then
		return window.btoa(window.unescape(window.encodeURIComponent(s)));
		#case ifcode NODEJS then
		return Buffer.from(s).toString('base64');
		#endswitch
	}
	
	
	
	/**
	 * Base64 decode
	 * @param string s
	 * @return string 
	 */
	static string base64_decode(string s)
	{
		#switch
		#case ifcode PHP then
		return base64_decode($s);
		#case ifcode ES6 then
		return window.decodeURIComponent(window.escape(window.atob(s)));
		#case ifcode NODEJS then
		return Buffer.from(s, 'base64').toString('ascii');
		#endswitch
	}
	
	
	
	/**
	 * Base64 encode
	 * @param string s
	 * @return string 
	 */
	static string base64_encode_url(string s)
	{
		#switch
		#case ifcode PHP then
	
		$s = base64_encode($s);
		$s = str_replace('+', '-', $s);
		$s = str_replace('/', '_', $s);
		$s = str_replace('=', '', $s);
		return $s;
	
		#case ifcode ES6 then
		s = this.base64_encode(ctx, s)
			.replace(new RegExp('\\+', 'g'), '-')
			.replace(new RegExp('\\/', 'g'), '_')
			.replace(new RegExp('=', 'g'), '')
		;
		return s;
		#case ifcode NODEJS then
		return Buffer.from(s).toString('base64');
		#endswitch
	}
	
	
	
	/**
	 * Base64 decode
	 * @param string s
	 * @return string 
	 */
	static string base64_decode_url(string s)
	{
		#switch
		#case ifcode PHP then
		$c = 4 - strlen($s) % 4;
		if ($c < 4 && $c > 0) $s .= str_repeat('=', $c);
		$s = str_replace('-', '+', $s);
		$s = str_replace('_', '/', $s);
		return base64_decode($s);
		#case ifcode ES6 then
		var c = 4 - s.length % 4;
		if (c < 4 && c > 0) s = s + '='.repeat(c);
		s = s.replace(new RegExp('-', 'g'), '+')
			.replace(new RegExp('_', 'g'), '/')
		;
		return this.base64_decode(ctx, s);
		#case ifcode NODEJS then
		return Buffer.from(s, 'base64').toString('ascii');
		#endswitch
	}
	
	

	/* ================================= Other Functions ================================= */
	
	
	
	/*
	 * Generate password
	 *
	 * @param int length The lenght of the password
	 * @param string options What kinds of the char can be in password
	 *   a - lower case chars
	 *   b - upper case chars
	 *   c - numbers
	 *   d - special chars !@#$%^&?*_-+=~(){}[]<>|/,.:;\\
	 *   e - quotes `"'
	 */	
	public static string randomString(int length=16, string options="abc")
	{
		string s = "";
		if (rs::strpos(options, "a") >= 0) s ~= "abcdefghjkmnpqrstuvwxyz";
		if (rs::strpos(options, "b") >= 0) s ~= "ABCDEFGHJKMNPQRSTUVWXYZ";
		if (rs::strpos(options, "c") >= 0) s ~= "1234567890";
		if (rs::strpos(options, "d") >= 0) s ~= "!@#$%^&?*_-+=~(){}[]<>|/,.:;\\";
		if (rs::strpos(options, "e") >= 0) s ~= "`\"\'";
		string res = "";
		int c = rs::strlen(s);
		for (int i=0; i<length; i++){
			int k = rtl::random(0, c-1);
			res ~= s[k];
		}
		return res;
	}
	
	
	/**
	 * Returns true if value is primitive value
	 * @return boolean 
	 */
	public static bool isPrimitiveValue(var value)
	{
		if (rtl::isScalarValue(value)) return true;
		if (value instanceof Vector) return true;
		if (value instanceof Map) return true;
		return false;
	}
	
	
	
	/**
	 * Convert bytes to string
	 * @param Vector<byte> arr - vector of the bytes
	 * @string charset - charset of the bytes vector. Default utf8
	 * @return string
	 */
	public static string bytesToString(Collection<byte> arr, string charset="utf8")
	{
		#switch
		#case ifcode PHP then
		$arr = array_map( function($byte){ return chr($byte); }, $arr->_getArr() );
		$s = implode("", $arr);
		return $s;
		#case ifcode ES6 then
		var decoder = new TextDecoder(charset);
		var bytes = new Uint8Array(arr);
		return decoder.decode(bytes);
		#case ifcode NODEJS then
		#endswitch
	}
	
	
	
	/**
	 * Convert string to bytes
	 * @param string s - incoming string
	 * @param charset - Result bytes charset. Default utf8
	 * @return Collection<byte> output collection
	 */
	lambda Collection<byte> toString(Collection<byte> arr, string charset="utf8")
	{
		return static::bytesToString(arr, charset);
	}
	
	
	
	/**
	 * Convert string to bytes
	 * @param string s - incoming string
	 * @param Vector<byte> arr - output vector
	 * @param charset - Result bytes charset. Default utf8
	 */
	lambda Collection<byte> stringToBytes(string s, Vector<byte> arr, string charset="utf8")
	{
		#switch
		#case ifcode PHP then
		#case ifcode ES6 then
		var encoder = new TextEncoder(charset);
		var bytes = encoder.encode(s);
		return Runtime.Collection.from(bytes);
		#case ifcode NODEJS then
		#endswitch
	}
	
	
	
	/**
	 * Convert string to bytes
	 * @param string s - incoming string
	 * @param charset - Result bytes charset. Default utf8
	 * @return Collection<byte> output collection
	 */
	lambda Collection<byte> toBytes(string s, string charset="utf8")
	{
		return static::stringToBytes(s, charset);
	}
	
	
	
	/**
	 * Translate message
	 * @params string message - message need to be translated
	 * @params Dict params - Messages params. Default null.
	 * @params string locale - Different locale. Default "".
	 * @return string - translated string
	 */
	public static string translate
	(
		string message, Dict params = null, string locale = "", 
		Object context = null
	)
	{
		if (context == null) context = self::getContext();
		if (context != null)
		{
			context.translate(message, params, locale);
		}	
		return message;
	}
	
	
	
	/**
	 * Retuns css hash 
	 * @param string component class name
	 * @return string hash
	 */
	static memorize string getCssHash(string s)
	{
		string r = "";
		string a = "1234567890abcdef";
		int sz = rs::strlen(s);
		int h = 0;
		for (int i=0; i<sz; i++)
		{
			int c = rs::ord( rs::substr(s, i, 1) );
			h = ((h << 2) + (h >> 14) + c) & 65535;
		}
		int p = 0;
		while (h != 0 or p < 4)
		{
			int c = h & 15;
			h = h >> 4;
			r ~= rs::substr(a, c, 1);
			p = p + 1;
		}
		return r;
	}
	
	
	
	/**
	 * Normalize UIStruct
	 */
	static Collection<UIStruct> normalizeUIVector(var data)
	{
		if (data instanceof Collection)
		{
			Vector<UIStruct> res = new Vector();
			for (int i=0; i<data.count(); i++)
			{
				var item = data.item(i);
				if (item instanceof Collection)
				{
					Vector<UIStruct> new_item = static::normalizeUIVector(item);
					res.appendVector(new_item);
				}
				else if (item instanceof UIStruct)
				{
					res.push(item);
				}
				else if (rtl::isString(item))
				{
					res.push(
						new UIStruct
						{
							"kind": UIStruct::TYPE_RAW,
							"content": rtl::toString(item),
						}
					);
				}
			}
			
			return res.toCollection();
		}
		
		else if (data instanceof UIStruct)
		{
			return new Collection( static::normalizeUI(data) );
		}
		
		else if (rtl::isString(data))
		{
			return new Collection( static::normalizeUI(data) );
		}
		
		return null;
	}
	
	
	
	/**
	 * Normalize UIStruct
	 */
	static UIStruct normalizeUI(var data)
	{
		if (data instanceof UIStruct)
		{
			Map obj = {
				"children": static::normalizeUIVector(data.children),
			};
			
			if (data.props != null and data.props instanceof Map)
			{
				obj.set("props", data.props.toDict());
			}
			
			return data.copy(obj);
		}
		else if (rtl::isString(data))
		{
			return new UIStruct
			{
				"kind": UIStruct::TYPE_RAW,
				"content": rtl::toString(data),
			};
		}
		return null;
	}
	
	
	
	
	/* Lambda Functions */
	
	
	lambda fn isInstance(string class_name) =>
		bool (var item) use (class_name) => rtl::is_instance(item, class_name)
	;
	
	
	/**
	 * Equal two struct by key
	 */
	lambda fn equal(var value)
		=> bool (var item) use (value)
			=> item == value
	;
	
	
	
	/**
	 * Equal two struct by key
	 */
	lambda fn equalNot(var value)
		=> bool (var item) use (value)
			=> item != value
	;
	
	
	
	/**
	 * Returns attr of item
	 */
	lambda fn attr(string key, var def_value)
		=> bool (CoreStruct item1) use (key, def_value)
			=> item1.takeValue(key, def_value)
	;
	
	
	
	/**
	 * Equal two struct by key
	 */
	lambda fn equalItemKey(string key)
		=> bool (CoreStruct item1, var value) use (key)
			=> item1.takeValue(key) == value
	;
	
	
	
	/**
	 * Returns max id from items
	 */
	lambda int getMaxIdFromItems(Collection<CoreStruct> items, int start = 0) =>
		items.reduce
		(
			int (int value, CoreStruct item) => item.id > value ? item.id : value,
			start
		)
	;
	
	
}