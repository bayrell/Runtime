/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.Interfaces.StringInterface;
use Runtime.Collection;
use Runtime.CoreStruct;
use Runtime.Dict;


class rtl
{
	
	static bool @isBrowser()
	{
		#switch
		#case ifcode JAVASCRIPT then
		return typeof window !== "undefined";
		#endswitch
		return false;
	}
	
	
	
	/**
	 * Define props
	 */
	static bool @defProp(var obj, var name)
	{
		#switch
		#case ifcode JAVASCRIPT then
		Object.defineProperty
		(
			obj,
			name,
			{
				get:() => { return obj["__" + name] },
				set:(value) => {
					var AssignStructValueError = use("Runtime.Exceptions.AssignStructValueError");
					throw new AssignStructValueError(null, name); 
				}
			}
		);
		#endswitch
	}
	
	
	
	/**
	 * Define class
	 */
	static bool @defClass(var obj)
	{
		#switch
		#case ifcode ES6 then
		if (Runtime.rtl._classes == undefined) Runtime.rtl._classes = {};
		Runtime.rtl._classes[obj.getCurrentClassName()] = obj;
		#endswitch
	}
	
	
	
	/**
	 * Find class instance by name. If class does not exists return null.
	 * @return var - class instance
	 */
	static var @find_class(string class_name)
	{
		#switch
		#case ifcode PHP then
		return "\\" . preg_replace("/\\./", "\\", $class_name);
		
		#case ifcode ES6 then
		if (class_name instanceof Function)
			return class_name;
		
		return Runtime.rtl._classes[class_name];
		
		if (class_name instanceof Runtime.CoreObject) class_name = class_name.getClassName();
		else if (class_name instanceof Object) class_name = class_name.constructor.name;
		
		if (Runtime.rtl._classes==undefined) Runtime.rtl._classes = {};
		if (Runtime.rtl._classes[class_name]!=undefined) return Runtime.rtl._classes[class_name];
		
		var arr = class_name.split('.');
		var obj = window;
		
		for (var i=0; i<arr.length; i++){
			var key = arr[i];
			if (obj[key] == undefined)
				return null;
			obj = obj[key];
		}
		
		Runtime.rtl._classes[class_name] = obj;
		return obj;
		
		#case ifcode NODEJS then
		if (class_name instanceof Function)
			return class_name;
		
		return use(class_name);
		
		#endswitch
	}
	
	
	
	/**
	 * Returns true if class instanceof class_name
	 * @return bool
	 */
	static bool is_instanceof(var obj, string class_name)
	{
		#switch
		#case ifcode PHP then
		
		$class_name = self::find_class($class_name);
		if ($obj == null) return false;
		if (gettype($obj) != "object") return false;
		if (is_subclass_of($obj, $class_name)){ return true;}
		return is_a($obj, $class_name);
	
		#case ifcode JAVASCRIPT then
		
		var c = this.find_class(class_name);
		if (c == null) return false;
		return c.prototype.isPrototypeOf(obj);
	
		#endswitch
	}
	
	
	
	/**
	 * Returns true if obj implements interface_name
	 * @return bool
	 */
	static bool is_implements(var obj, string interface_name)
	{
		#switch
		#case ifcode PHP then
	
		$class_name = get_class($obj);
		return self::class_implements($class_name, $interface_name);
	
		#case ifcode JAVASCRIPT then
		if (obj == undefined) return false;
		if (obj.constructor.__implements__ == undefined) return false;
		return obj.constructor.__implements__.indexOf(interface_name) != -1;
	
		#endswitch
	}
	
	
	
	/**
	 * Returns true if class exists
	 * @return bool
	 */
	static bool class_exists(string class_name)
	{
		#switch
		#case ifcode PHP then
		$class_name = static::find_class($class_name);
		return class_exists($class_name);
		
		#case ifcode JAVASCRIPT then
		var obj = this.find_class(class_name);
		if (!this.exists(ctx, obj)) return false;
		return true;
		
		#endswitch
	}
	
	
	
	/**
	 * Returns true if class exists
	 * @return bool
	 */
	static bool class_implements(string class_name, string interface_name)
	{
		#switch
		#case ifcode PHP then
		
		$class_name = self::find_class($class_name);
		$interface_name = self::find_class($interface_name);
		$arr = @class_implements($class_name, true);
		if ($arr == false){
			return false;
		}
		foreach ($arr as $name)
		{
			if ($name == $interface_name or "\\" . $name == $interface_name)
				return true;
		}
		return false;
		
		#case ifcode JAVASCRIPT then
		var obj = this.find_class(class_name);
		var obj2 = this.find_class(interface_name);
		
		while (obj != null){
			if (obj.__implements__){
				if (obj.__implements__.indexOf( obj2 ) > -1 ){
					return true;
				}
			}
			obj = obj.__proto__;
		}
		
		return false;
		
		#endswitch
	}
	
	
	
	/**
	 * Returns interface of class
	 * @param string class_name
	 * @return Collection<string>
	 */
	static Collection<string> getInterfaces(string class_name)
	{
		#switch
		#case ifcode PHP then
		$arr = array_values(class_implements(rtl::find_class($class_name)));
		$arr = array_map
		(
			function($s){ return str_replace("\\", ".", $s); },
			$arr
		);
		return \Runtime\Collection::from($arr);
		#case ifcode JAVASCRIPT then
		return this.find_class(class_name).__implements__;
		#endswitch
	}
	
	
	
	/**
	 * Returns true if class exists
	 * @return bool
	 */
	static bool method_exists(string class_name, string method_name)
	{
		#switch
		#case ifcode PHP then
	
		$class_name = static::find_class($class_name);
		if (!class_exists($class_name)) return false;
		if (!method_exists($class_name, $method_name)) return false;
		return true;
	
		#case ifcode JAVASCRIPT then
	
		var obj = this.find_class(class_name);
		if (!this.exists(ctx, obj)) return false;
		if (
			!this.exists(ctx, obj[method_name]) && 
			!this.exists(ctx, obj.prototype) && 
			!this.exists(ctx, obj.prototype[method_name])
		) return false;
		return true;
	
		#endswitch
	}
	
	
	
	/**
	 * Create object by class_name. If class name does not exists return null
	 * @return Object
	 */
	static Object newInstance(string class_name, Vector<var> args = null)
	{
		#switch
		#case ifcode PHP then
	
		$class_name = static::find_class($class_name);
		if ($args == null)
			return new $class_name($ctx);
		$r = new \ReflectionClass($class_name);
		$arr = $args->_arr;
		array_unshift($arr, $ctx);
		return $r->newInstanceArgs($arr);
	
		#case ifcode JAVASCRIPT then
	
		var obj = this.find_class(class_name);
		if (!this.exists(ctx, obj)) return null;
		if (!(obj instanceof Function)) return null;
		if (args == undefined || args == null) args = [];
		args = args.slice(); 
		args.unshift(null);
		args.unshift(ctx);
		var f = Function.prototype.bind.apply(obj, args);
		return new f;
	
		#endswitch
	}
	
	
	
	/**
	 * Returns callback
	 * @return fn
	 */
	static fn method(var obj, string method_name)
	{
		#switch
		#case ifcode PHP then
	
		return new \Runtime\Callback(static::find_class($obj), $method_name);
		
		#case ifcode JAVASCRIPT then
		
		var save = obj;
		if (!(obj instanceof Object))
		{
			var find_obj = this.find_class(obj);
			if (find_obj == null)
			{
				throw new Error("Object " + obj + " not found");
			}
			obj = find_obj;
		}
		
		if (obj[method_name] == null || obj[method_name] == "undefined")
		{
			var class_name = "";
			if (obj.getClassName != undefined) class_name = obj.getClassName();
			else if (obj.getCurrentClassName != undefined) class_name = obj.getCurrentClassName();
			else class_name = save;
			throw new Error("Method " + method_name + " not found in " + class_name);
		}
		
		return function(obj, method_name){ return function () {
			return obj[method_name].apply(obj, arguments);
		}}(obj, method_name);
		
		#endswitch
	}
	
	
	
	/**
	 * Returns callback
	 * @return fn
	 */
	static var apply(fn f, Collection args)
	{
		#switch
		#case ifcode PHP then
		
		$arr = ($args != null) ? $args->_getArr() : [];
		array_unshift($arr, $ctx);
		if ($f instanceof \Runtime\Callback)
		{
			return $f->invokeArgs($arr);
		}
		if (gettype($f) == "string") $f = static::find_class($f);
		return call_user_func_array($f, $arr);
	
		#case ifcode JAVASCRIPT then
		
		if (args == null) args = [];
		args.unshift(ctx);
		if (this.isString(ctx, f))
		{
			var a = f.split("::");
			var c = a[0]; var m = a[1];
			c = this.find_class(c);
			f = c[m];
			return f.apply(c, args);
		}
		return f.apply(null, args);
		#endswitch
	}
	
	
	
	/**
	 * Call await method
	 * @return fn
	 */
	static var applyAwait(fn f, Collection args)
	{
		#switch
		#case ifcode PHP then
		
		$arr = $args->_getArr();
		array_unshift($arr, $ctx);
		if ($f instanceof \Runtime\Callback)
		{
			return $f->invokeArgs($arr);
		}
		return call_user_func_array($f, $arr);
		
		#case ifcode JAVASCRIPT then
		args.unshift(ctx);
		var t = new Runtime.AsyncThread(ctx, {
			"tasks": Runtime.Collection.from([
				new Runtime.AsyncTask(ctx, {
					"pos": "0",
					"f": f.apply(null, args),
				})
			])
		});
		Runtime.AsyncThread.run(ctx, t);
		#endswitch
	}
	
	
	
	/**
	 * Returns callback
	 * @return var
	 */
	static var attr(var item, Collection path, var def_val = null)
	{
		#switch
		#case ifcode PHP then
		
		if ($item === null) return $def_val;
		if (count($path->_arr) == 0) 
		{
			return $item;
		}
		$key = $path->first($ctx);
		$path = $path->removeFirstIm($ctx);
		$val = $def_val;
		if ($item instanceof \Runtime\Dict or $item instanceof \Runtime\Collection)
		{
			$item = $item->get($ctx, $key, $def_val);
			$val = static::attr($ctx, $item, $path, $def_val);
			return $val;
		}
		else if ($item instanceof \Runtime\CoreStruct)
		{
			$item = $item->takeValue($ctx, $key, $def_val);
			$val = static::attr($ctx, $item, $path, $def_val);
			return $val;
		}
		return $val;
		
		#case ifcode JAVASCRIPT then		
		if (def_val == undefined) def_val = null;
		if (item === null) return def_val;
		if (path.count() == 0)
		{
			return item;
		}
		var key = path.first(ctx);
		var path = path.removeFirstIm(ctx);
		var val = def_val;
		if (item instanceof Runtime.Dict || item instanceof Runtime.Collection)
		{
			item = item.get(ctx, key, def_val);
			val = this.attr(ctx, item, path, def_val);
			return val;
		}
		else if (item instanceof Runtime.CoreStruct)
		{
			item = item.takeValue(ctx, key, def_val);
			val = this.attr(ctx, item, path, def_val);
			return val;
		}
		return val;
		
		#endswitch
	}
	
	
	
	/**
	 * Update current item
	 * @return var
	 */
	static var setAttr(var item, Collection attrs, var new_value)
	{
		fn f = var (Collection attrs, var data, var new_value, var f)
		{
			if (attrs.count() == 0) return new_value;
			if (data == null) return null;
			
			var new_data = null;
			var attr_name = attrs.first();
			
			if (data instanceof CoreStruct)
			{
				var attr_data = data.get(attr_name, null);
				var res = f(attrs.removeFirstIm(), attr_data, new_value, f);			
				new_data = data.copy( (new Map()).set(attr_name, res) );
			}
			else if (data instanceof Dict)
			{
				var attr_data = data.get(attr_name, null);
				var res = f(attrs.removeFirstIm(), attr_data, new_value, f);			
				new_data = data.setIm( attr_name, res );
			}
			else if (data instanceof Collection)
			{
				var attr_data = data.get(attr_name, null);
				var res = f(attrs.removeFirstIm(), attr_data, new_value, f);			
				new_data = data.setIm( attr_name, res );
			}
			
			return new_data;
		};
		
		var new_item = f(attrs, item, new_value, f);
		return new_item;
	}
	
	
	
	/**
	 * Returns value
	 * @param var value
	 * @param var def_val
	 * @param var obj
	 * @return var
	 */
	static var @to(var v, var o)
	{
		var e = o["e"];
		if (e == "mixed" or e == "primitive" or e == "var" or e == "fn" or e == "callback") return v;
		if (e == "bool") return static::toBool(null, v);
		else if (e == "string") return static::toString(null, v);
		else if (e == "int") return static::toInt(null, v);
		else if (e == "float") return static::toFloat(null, v);
		else if (rtl::is_instanceof(null, v, e)) return v;
		return v;
	}
	
	
	
	/**
	 * Returns value if value instanceof type_value, else returns def_value
	 * @param var value
	 * @param string type_value
	 * @param var def_value
	 * @param var type_template
	 * @return var
	 */
	static var @convert(var value, string type_value, var def_value = null, string type_template = "")
	{
		return value;
	}
	
	
	
	/**
	 * Returns true if value instanceof tp
	 * @param var value
	 * @param string tp
	 * @return bool
	 */
	static var checkValue(var value, string tp)
	{
		if (tp == "int") return self::isInt(value);
		if (tp == "float" or tp == "double") return self::isDouble(value);
		if (tp == "string") return self::isString(value);
		if (tp == "bool" or tp == "boolean") return self::isBoolean(value);
		if (rtl::is_instanceof(value, tp)){ return true;}
		return false;
	}
	
	
	
	/**
	 * Return true if value is exists
	 * @param var value
	 * @return bool
	 */
	static bool exists(var value)
	{
		#switch
		#case ifcode PHP then
		return isset($value);
		
		#case ifcode JAVASCRIPT then
		
		return (value != null) && (value != undefined);
		#endswitch
	}
	
	
	
	/**
	 * Returns true if value is scalar value
	 * @return bool 
	 */
	static bool isScalarValue(var value)
	{
		if (value == null) return true;
		if (rtl::isString(value)) return true;
		if (rtl::isNumber(value)) return true;
		if (rtl::isBoolean(value)) return true;
		return false;
	}
	
	
	
	/**
	 * Return true if value is boolean
	 * @param var value
	 * @return bool
	 */
	static bool isBoolean(var value)
	{
		if (value === false or value === true) return true;
		return false;
	}
	
	
	
	/**
	 * Return true if value is number
	 * @param var value
	 * @return bool
	 */
	static bool isInt(var value)
	{
		#switch
		#case ifcode PHP then
		
		return is_int($value);
		
		#case ifcode JAVASCRIPT then
		
		if (typeof value != "number") return false;
		if (value % 1 !== 0) return false;
		return true;
		
		#endswitch
	}
	
	
	
	/**
	 * Return true if value is number
	 * @param var value
	 * @return bool
	 */
	static bool isDouble(var value)
	{
		#switch
		#case ifcode PHP then
		return is_int($value) or is_float($value);
		
		#case ifcode JAVASCRIPT then
		
		if (typeof value == "number") return true;
		return false;
		
		#endswitch
	}
	
	
	
	/**
	 * Return true if value is number
	 * @param var value
	 * @return bool
	 */
	static bool isNumber(var value)
	{
		#switch
		#case ifcode PHP then
		
		return is_int($value) or is_float($value);
		#case ifcode JAVASCRIPT then
		
		if (typeof value == "number") return true;
		return false;
		
		#endswitch
	}
	
	
	
	/**
	 * Return true if value is string
	 * @param var value
	 * @return bool
	 */
	static bool isString(var value)
	{
		#switch
		#case ifcode PHP then
		
		return is_string($value);
	
		#case ifcode JAVASCRIPT then
		
		if (typeof value == 'string') return true;
		else if (value instanceof String) return true;
		return false;
		
		#endswitch
	}
	
	
	
	/**
	 * Convert value to string
	 * @param var value
	 * @return string
	 */
	static string toString(var value)
	{
		#switch
		#case ifcode PHP then
		
		if ($value === null) return "";
		if ($value instanceof StringInterface) return $value->toString();
		return (string)$value;
		
		#case ifcode JAVASCRIPT then
		
		var _StringInterface = use("Runtime.Interfaces.StringInterface");
		/*if (isBrowser()) _StringInterface = Runtime.Interfaces.StringInterface; 
		else _StringInterface = StringInterface;*/
		
		if (value === null) return "";
		if (typeof value == 'string') return value;
		if (value instanceof String) return ""+value;
		if (this.is_implements(null, value, _StringInterface)) return value.toString();
		return ""+value;
		
		#endswitch
	}
	
	
	
	/**
	 * Convert value to string
	 * @param var value
	 * @return string
	 */
	static string @toStr(var value)
	{
		return static::toString(null, value);
	}
	
	
	
	/**
	 * Convert value to int
	 * @param var value
	 * @return int
	 */
	static int toInt(var val)
	{
		#switch
		#case ifcode PHP then
	
		$res = (int)$val;
		$s_res = (string)$res;
		$s_val = (string)$val;
		if ($s_res == $s_val)
			return $res;
		
		#case ifcode JAVASCRIPT then
		
		var res = parseInt(val);
		var s_res = new String(res);
		var s_val = new String(val);
		if (s_res.localeCompare(s_val) == 0)
			return res;
		
		#endswitch
		return 0;
	}
	
	
	
	/**
	 * Convert value to boolean
	 * @param var value
	 * @return bool
	 */
	static bool toBool(var val)
	{
		#switch
		#case ifcode PHP then
		
		if ($val === false || $val === "false") return false;
		if ($val === true || $val === "true") return true;
		$res = (bool)$val;
		$s_res = (string)$res;
		$s_val = (string)$val;
		if ($s_res == $s_val)
			return $res;
		
		#case ifcode JAVASCRIPT then
		
		var res = false;
		if (val == false || val == 'false') return false;
		if (val == true || val == 'true') return true;
		var s_res = new String(res);
		var s_val = new String(val);
		if (s_res.localeCompare(s_val) == 0)
			return res;
		
		#endswitch
		return false;
	}
	
	
	
	/**
	 * Convert value to float
	 * @param var value
	 * @return float
	 */
	static bool toFloat(var val)
	{
		#switch
		#case ifcode PHP then
		
		$res = floatval($val);
		$s_res = (string)$res;
		$s_val = (string)$val;
		if ($s_res == $s_val)
			return $res;
		
		#case ifcode JAVASCRIPT then
		
		var res = parseFloat(val);
		var s_res = new String(res);
		var s_val = new String(val);
		if (s_res.localeCompare(s_val) == 0)
			return res;
		
		#endswitch
		return 0;
	}
	
	
	
	/**
	 * Round up
	 * @param double value
	 * @return int
	 */
	static string ceil(double value)
	{
		#switch
		#case ifcode PHP then
		
		return ceil($value);
		
		#case ifcode JAVASCRIPT then
		
		return Math.ceil(value);
		
		#endswitch
	}
	
	
	
	/**
	 * Round down
	 * @param double value
	 * @return int
	 */
	static string floor(double value)
	{
		#switch
		#case ifcode PHP then
		
		return floor($value);
		
		#case ifcode JAVASCRIPT then
		
		return Math.floor(value);
		
		#endswitch
	}
	
	
	
	/**
	 * Round down
	 * @param double value
	 * @return int
	 */
	static string round(double value)
	{
		#switch
		#case ifcode PHP then
		
		return round($value);
		
		#case ifcode JAVASCRIPT then
		
		return Math.round(value);
		
		#endswitch
	}
	
	
	
	/* ====================== Chains ====================== */
	
	/**
	 * Apply async chain
	 */
	static async Collection<var> chainAwait(Collection<string> chain, Collection<var> args)
	{
		for (int i=0; i<chain.count(); i++)
		{
			string chain_name = chain.item(i);
			args = await rtl::apply(chain_name, args);
		}
		return args;
	}
	
	
	
	/**
	 * Apply chain
	 */
	static Collection<var> chain(Collection<string> chain, Collection<var> args)
	{
		for (int i=0; i<chain.count(); i++)
		{
			string chain_name = chain.item(i);
			args = rtl::apply(chain_name, args);
		}
		return args;
	}
	
	
	
	/* ================ Memorize functions ================ */
	
	
	static var _memorize_cache = null;
	static var _memorize_not_found = null;
	static var _memorize_hkey = null;
	
	
	static bool @_memorizeValidHKey(var hkey, var key)
	{
		#switch
		#case ifcode PHP then
		if ( static::$_memorize_hkey == null ) static::$_memorize_hkey = [];
		if ( !isset(static::$_memorize_hkey[$hkey]) ) return false;
		if ( static::$_memorize_hkey[$hkey] == $key ) return true;
		return false;
		
		#case ifcode JAVASCRIPT then
		#endswitch
	}
	
	
	
	/**
	 * Clear memorize cache
	 */
	static void @_memorizeClear()
	{
		#switch
		#case ifcode JAVASCRIPT then
		this._memorize_cache = null;
		#case ifcode PHP then
		static::$_memorize_cache = [];
		static::$_memorize_hkey = [];
		#endswitch
	}
	
	
	
	/**
	 * Returns cached value
	 */
	static string @_memorizeValue(string name, var args)
	{
		#switch
		#case ifcode PHP then
		
		if (static::$_memorize_cache == null) return static::$_memorize_not_found;
		if (!isset(static::$_memorize_cache[$name])) return static::$_memorize_not_found;
		
		$arr = &static::$_memorize_cache[$name];
		$sz = count($args);
		for ($i=0; $i<$sz; $i++)
		{
			$key = &$args[$i];
			$hkey = null; 
			if (gettype($key) == 'object') $hkey = spl_object_hash($key); else $hkey = $key;
			if ($i == $sz - 1)
			{
				if (in_array($hkey, array_keys($arr)))
				{
					return $arr[$hkey];
				}
				return static::$_memorize_not_found;
			}
			else
			{
				if (!isset($arr[$hkey])) return static::$_memorize_not_found;
				$arr = &$arr[$hkey];
			}
		}
		
		return static::$_memorize_not_found;
		
		#case ifcode JAVASCRIPT then
		if (this._memorize_cache == null) return this._memorize_not_found;
		if (this._memorize_cache[name] == undefined) return this._memorize_not_found;
		var arr = this._memorize_cache[name];
		var sz = args.length;
		for (var i=0; i<sz; i++)
		{
			var key = args[i];
			var hkey = null;
			if (key != null && typeof key == 'object')
			{
				if (key.__uq__ != undefined) hkey = key.__uq__;
				else return this._memorize_not_found;
			}
			else if (typeof key == 'string') hkey = "__s_" + key;
			else hkey = key;
			if (i == sz - 1)
			{
				if (arr[hkey] == undefined) return this._memorize_not_found;
				return arr[hkey];
			}
			else
			{
				if (arr[hkey] == undefined) arr[hkey] = {};
				arr = arr[hkey];
			}
		}
		
		return this._memorize_not_found;
		
		#endswitch
	}
	
	
	
	/**
	 * Returns cached value
	 */
	static string @_memorizeSave(string name, var args, var value)
	{
		#switch
		#case ifcode PHP then
		
		if (static::$_memorize_cache == null) static::$_memorize_cache = [];
		if (!isset(static::$_memorize_cache[$name])) static::$_memorize_cache[$name] = [];
		
		$arr = &static::$_memorize_cache[$name];
		$sz = count($args);
		for ($i=0; $i<$sz; $i++)
		{
			$key = &$args[$i];
			$hkey = null; 
			if (gettype($key) == 'object') $hkey = spl_object_hash($key); else $hkey = $key;
			if ($i == $sz - 1)
			{
				$arr[$hkey] = $value;
			}
			else
			{
				if (!isset($arr[$hkey])) $arr[$hkey] = [];
				else if (!static::_memorizeValidHKey($hkey, $key)) $arr[$hkey] = [];
				$arr = &$arr[$hkey];
			}
		}
		
		#case ifcode JAVASCRIPT then
		
		if (this._memorize_cache == null) this._memorize_cache = {};
		if (this._memorize_cache[name] == undefined) this._memorize_cache[name] = {};
		var arr = this._memorize_cache[name];
		var sz = args.length;
		for (var i=0; i<sz; i++)
		{
			var key = args[i];
			var hkey = null;
			if (key != null && typeof key == 'object')
			{
				if (key.__uq__ != undefined) hkey = key.__uq__;
				else hkey = null;
			}
			else if (typeof key == 'string') hkey = "__s_" + key;
			else hkey = key;
			if (i == sz - 1)
			{
				arr[hkey] = value;
			}
			else
			{
				if (arr[hkey] == undefined) arr[hkey] = {};
				arr = arr[hkey];
			}
		}
		
		#endswitch
	}
	
	
	
	/* ================ Dirty functions ================ */
	
	
	/**
	 * Sleep
	 */
	static async void usleep(int time)
	{
		#switch
		#case ifcode PHP then
		usleep($time);
		#endswitch
	}
	
	
	
	/**
	 * Returns unique value
	 * @param bool flag If true returns as text. Default true
	 * @return string
	 */
	static string unique(bool flag = true)
	{
		#switch
		#case ifcode PHP then
		
		return uniqid();
		
		#case ifcode JAVASCRIPT then
		
		if (flag == undefined) flag = true;
		if (flag)
			return "" + (new Date).getTime() + Math.floor((Math.random() * 899999 + 100000));
		return Symbol();
		
		#endswitch
	}
	
	
	
	/**
	 * Returns random value x, where a <= x <= b
	 * @param int a
	 * @param int b
	 * @return int
	 */
	static int random(int a, int b)
	{
		#switch
		#case ifcode PHP then
		
		if (PHP_VERSION_ID < 70000) return mt_rand($a, $b);
		return random_int($a, $b);
		
		#case ifcode JAVASCRIPT then
		
		if (window != undefined && window.crypto != undefined && window.crypto.getRandomValues != undefined)
		{
			var s = new Uint32Array(1);
			window.crypto.getRandomValues(s);
			return Math.floor(s[0] / 4294967296 * (b - a + 1) + a);
		}
		return Math.floor(Math.random() * (b - a + 1) + a);
			
		#endswitch
	}
	
	
	
	/**
	 * Returns current unix time in seconds
	 * @return int
	 */
	static int time()
	{
		#switch
		#case ifcode PHP then
		
		return time();
		
		#case ifcode JAVASCRIPT then
		
		return Math.round((new Date()).getTime() / 1000);
		
		#endswitch
	}
	
	
	
	/**
	 * Clone var
	 * @param {var} value - Variable
	 * @return {var} result
	 */
	static var clone(var val)
	{
		#switch
		#case ifcode PHP then
		
		if ($val == null) return null;
		if (self::isScalarValue($val)) return $val;
		return clone $val;
		
		#case ifcode JAVASCRIPT then
		
		var Collection = use("Runtime.Collection");
		var Dict = use("Runtime.Dict");
		var CoreObject = use("Runtime.CoreObject");
		var CoreStruct = use("Runtime.CoreStruct");
		var FakeStruct = use("Runtime.FakeStruct");
		var Reference = use("Runtime.Reference");
		
		if (val == null)
			return null;
		
		else if (val instanceof Number || typeof val == "number")
		{
			return val;
		}
		else if (val instanceof String || typeof val == "string")
		{
			return (new String(val)).toString();
		}
		else if (val instanceof Boolean || typeof val == "boolean")
		{
			return val;
		}
		else if (typeof val == "symbol")
		{
			return Symbol();
		}
		else if (val instanceof Date)
		{
			return new Date(val);
		}
		else if (typeof val == 'object' && val.nodeType && typeof val.cloneNode == "function")
		{
			return val.cloneNode(true);
		}
		else if (val instanceof Collection)
		{
			var res = val.constructor.Instance();
			for (var i=0;i<val.length;i++)
			{
				res.push(ctx, this.clone(ctx, val[i]));
			}
			return res;
		}
		else if (val instanceof Dict)
		{
			var res = val.constructor.Instance();
			for (var key in val._map)
			{
				res._map[key] = this.clone(ctx, val._map[key]);
			}
			return res;
		}
		else if (Array.isArray(val))
		{	
			var proto = Object.getPrototypeOf(val);
			var res = Object.create(proto);
			for (var i=0;i<val.length;i++)
			{
				res.push(ctx, this.clone(ctx, val[i]));
			}
			return res;
		}
		else if (val instanceof CoreStruct)
		{
			return val;
		}
		else if (val instanceof FakeStruct)
		{
			return val.clone(ctx);
		}
		else if (val instanceof Reference)
		{
			return new Reference(ctx, val.ref);
		}
		else if (val instanceof CoreObject || typeof val == 'object')
		{
			var proto = Object.getPrototypeOf(val);
			var res = Object.create(proto);
			var a = Object.getOwnPropertyNames(val);
			for (var i=0;i<a.length;i++)
			{
				var key = a[i];
				res[key] = this.clone(ctx, val[key]);
			}
			return res;
		}
		
		return null;
		
		#endswitch
	}
	
	
	
	#ifdef BACKEND then
	
	/**
	 * Returns module path. For backend only
	 */
	static string getModulePath(string module_name)
	{
		#switch
		#case ifcode PHP then
		$class = "\\" . preg_replace("/\\./", "\\", $module_name . ".ModuleDescription");
		$reflector = new \ReflectionClass($class);
		$path = $reflector->getFileName();
		return dirname( dirname($path) );
		#endswitch
		return "";
	}
	
	
	/**
	 * Read local file
	 */
	static async string readLocalFile(string path, string ch = "utf8", string chroot = "")
	{
		if (rs::substr(chroot, -1) != "/") chroot ~= "/";
		string filepath = chroot ~ path;
		#switch
		#case ifcode PHP then
		$filepath = realpath($filepath);
		if ($filepath == false) return "";
		if ($chroot != "" && strpos($filepath, $chroot) !== 0) return "";
		if (!file_exists($filepath)) return "";
		return file_get_contents($filepath);
		#endswitch
		return "";
	}
	
	
	#endif
	
	
	
	/* =================== Deprecated =================== */
	
	
	/**
	 * Round down
	 * @param double value
	 * @return int
	 */
	static string dump(var value)
	{
		#switch
		#case ifcode PHP then
		
		var_dump($value);
		
		#case ifcode JAVASCRIPT then
		
		console.log(value);
		
		#endswitch
	}
	
	
	/**
	 * Translate message
	 * @params string message - message need to be translated
	 * @params MapInterface params - Messages params. Default null.
	 * @params string locale - Different locale. Default "".
	 * @return string - translated string
	 */
	public static string translate
	(
		string message, 
		Dict params = null, 
		string locale = "", 
		Object context = null
	)
	{
		#switch
		#case ifcode PHP then
		return self::callStaticMethod("Runtime.RuntimeUtils", "translate", [$message, $params, $locale, $context]);
		#case ifcode JAVASCRIPT then
		return this.callStaticMethod("Runtime.RuntimeUtils", "translate", [message, params, locale, context]);
		#endswitch
	}
	
	
	
	/**
	 * Json encode data
	 * @param var data
	 * @return string
	 */
	public static string json_encode(var data)
	{
		#switch
		#case ifcode PHP then
		return self::callStaticMethod("Runtime.RuntimeUtils", "json_encode", [$data]);
		#case ifcode JAVASCRIPT then
		return this.callStaticMethod("Runtime.RuntimeUtils", "json_encode", [data]);
		#endswitch
	}
	
	
	
	/**
	 * Call method
	 * @return Object
	 */
	static var f(fn f)
	{
		return f;
	}
	
	
	
	/**
	 * Returns value if value instanceof type_value, else returns def_value
	 * @param var value
	 * @param string type_value
	 * @param var def_value
	 * @param var type_template
	 * @return var
	 */
	static var correct(var value, var def_value = null, string type_value, string type_template = ""){
		return static::convert(value, type_value, def_value, type_template);
	}
	
	
	
	/**
	 * Convert module name to node js package
	 */
	static string convertNodeJSModuleName(string name)
	{
		#switch
		#case ifcode PHP then
		
		$arr1 = "qazwsxedcrfvtgbyhnujmikolp";
		$arr2 = "0123456789";
		$res = "";
		$sz = mb_strlen($name);
		$previsbig = false;
		for ($i = 0; $i < $sz; $i++){
			$ch = mb_substr($name, $i, 1);
			$ch2 = mb_strtoupper($ch);
			$ch3 = mb_strtolower($ch);
			$isAlpha = mb_strpos($arr1, $ch3) !== false;
			$isNum = mb_strpos($arr2, $ch3) !== false;
			if ($i > 0 && $ch == $ch2 && !$previsbig && $isAlpha){
				$res .= "-";
			}
			$res .= $ch3;
			if ($ch == $ch2){
				$previsbig = true;
			}
			else {
				$previsbig = false;
			}
			if (!$isAlpha && !$isNum){
				$previsbig = true;
			}
		}
		$res .= "-nodejs";
		return $res;
		
		#case ifcode JAVASCRIPT then
		
		name = new String(name);
		var arr1 = "qazwsxedcrfvtgbyhnujmikolp";
		var arr2 = "01234567890";
		var res = "";
		var sz = name.length;
		var previsbig = false;
		for (var i = 0; i < sz; i++){
			var ch = name[i];
			var ch2 = ch.toUpperCase();
			var ch3 = ch.toLowerCase();
			var isAlpha = arr1.indexOf(ch3) != -1;
			var isNum = arr2.indexOf(ch3) != -1;
			if (i > 0 && ch == ch2 && !previsbig && isAlpha){
				res += "-";
			}
			res += ch3;
			if (ch == ch2 && isAlpha){
				previsbig = true;
			}
			else {
				previsbig = false;
			}
			if (!isAlpha && !isNum){
				previsbig = true;
			}
		}
		res += "-nodejs";
		return res;
		
		#endswitch
	}
	
}


#switch
#case ifcode PHP then
rtl::$_memorize_not_found = (object) ['s' => 'memorize_key_not_found'];
#case ifcode JAVASCRIPT then
if (typeof rtl != 'undefined') rtl._memorize_not_found = {'s':'memorize_key_not_found','id':Symbol()};
if (typeof Runtime != 'undefined') Runtime.rtl._memorize_not_found = {'s':'memorize_key_not_found','id':Symbol()};
#endswitch
