/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Callback;
use Runtime.Collection;
use Runtime.Context;
use Runtime.Date;
use Runtime.DateTime;
use Runtime.Dict;
use Runtime.Map;
use Runtime.Monad;
use Runtime.SerializerJson;
use Runtime.Vector;
use Runtime.Exceptions.AssertException;


class rtl
{
	/* Log level */
	
	/**
	 * Fatal error. Application stoped
	 */
	static const int LOG_FATAL = 0;
	
	/**
	 * Critical error. Application damaged, but works
	 */	
	static const int LOG_CRITICAL = 2;
	
	/**
	 * Any Application error or exception
	 */	
	static const int LOG_ERROR = 4;
	
	/**
	 * Log warning. Developer should attention to this
	 */
	static const int LOG_WARNING = 6;
	
	/**
	 * Information about any event
	 */
	static const int LOG_INFO = 8;
	
	/**
	 * Debug level 1
	 */
	static const int LOG_DEBUG = 10;
	
	/**
	 * Debug level 2
	 */	
	static const int LOG_DEBUG2 = 12;
	
	/* Status codes */ 
	static const int STATUS_PLAN = 0;
	static const int STATUS_DONE = 1;
	static const int STATUS_PROCESS = 100;
	static const int STATUS_FAIL = -1;
	
	/* Errors */
	static const int ERROR_NULL = 0;
	static const int ERROR_OK = 1;
	static const int ERROR_PROCCESS = 100;
	static const int ERROR_FALSE = -100;
	static const int ERROR_RUNTIME = -1;
	static const int ERROR_UNKNOWN = -1;
	static const int ERROR_INDEX_OUT_OF_RANGE = -2;
	static const int ERROR_STOP_ITERATION = -3;
	static const int ERROR_ITEM_NOT_FOUND = -5;
	static const int ERROR_OBJECT_ALLREADY_EXISTS = -6;
	static const int ERROR_ASSERT = -7;
	static const int ERROR_REQUEST = -8;
	static const int ERROR_RESPONSE = -9;
	static const int ERROR_CSRF_TOKEN = -10;
	static const int ERROR_VALIDATION = -12;
	static const int ERROR_SERIALIZATION = -14;
	static const int ERROR_ASSIGN = -15;
	static const int ERROR_AUTH = -16;
	static const int ERROR_DUPLICATE = -17;
	static const int ERROR_API_NOT_FOUND = -18;
	static const int ERROR_API_WRONG_FORMAT = -19;
	static const int ERROR_API_WRONG_APP_NAME = -20;
	static const int ERROR_API = -21;
	static const int ERROR_CURL = -22;
	static const int ERROR_FATAL = -99;
	static const int ERROR_HTTP_CONTINUE = -100;
	static const int ERROR_HTTP_SWITCH = -101;
	static const int ERROR_HTTP_PROCESSING = -102;
	static const int ERROR_HTTP_OK = -200;
	static const int ERROR_HTTP_BAD_GATEWAY = -502;
	static const int ERROR_USER = -10000;
	
	/* Serializer */
	static const int ALLOW_OBJECTS = 1;
	static const int JSON_PRETTY = 8;
	
	
	/**
	 * Define class
	 */
	static bool defClass(var obj)
	{
		#switch
		#case ifcode ES6 then
		if (Runtime.rtl._classes == undefined) Runtime.rtl._classes = {};
		Runtime.rtl._classes[obj.getClassName()] = obj;
		#endswitch
	}
	
	
	/**
	 * Find class instance by name. If class does not exists return null.
	 * @return var - class instance
	 */
	static var findClass(string class_name)
	{
		#switch
		#case ifcode PHP then
		return "\\" . preg_replace("/\\./", "\\", $class_name);
		
		#case ifcode ES6 then
		
		if (typeof class_name == "string") class_name = window[class_name];
		if (class_name == undefined || class_name == null) return null;
		if (!(class_name instanceof Function)) class_name = class_name.constructor;
		
		return class_name instanceof Function ? class_name : null;
		
		#case ifcode NODEJS then
		if (class_name instanceof Function)
			return class_name;
		
		return use(class_name);
		
		#endswitch
	}
	
	
	/**
	 * Return class name
	 */
	static var className(var class_name)
	{
		var obj = this.findClass(class_name);
		return obj and obj.getClassName ? obj.getClassName() : "";
	}
	
	
	/**
	 * Returns parent class name
	 */
	static var parentClassName(var class_name)
	{
		var obj = this.findClass(class_name);
		var parentObj = obj ? Object.getPrototypeOf(obj) : null;
		return parentObj and parentObj.getClassName ? parentObj.getClassName() : "";
	}
	
	
	/**
	 * Returns true if class instanceof class_name
	 * @return bool
	 */
	static bool isInstanceOf(var obj, string class_name)
	{
		if (obj == null) return false;
		
		obj = static::className(obj);
		if (static::isString(obj))
		{
			if (obj == class_name) return true;
			string parent_class_name = static::parentClassName();
			while (parent_class_name != "")
			{
				if (parent_class_name == class_name) return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * Returns true if class exists
	 * @return bool
	 */
	static bool methodExists(string class_name, string method_name)
	{
		#switch
		#case ifcode PHP then
		
		if (gettype($class_name) == "object")
		{
			try
			{
				$r = new \ReflectionMethod(get_class($class_name),$method_name);
				if (!$r) return false;
				if ($r->isStatic()) return false;
				return true;
			}
			catch (\Exception $e) {}
			
			return false;
		}
		
		$class_name = static::find_class($class_name);
		if (!class_exists($class_name)) return false;
		
		try
		{
			$r = new \ReflectionMethod($class_name,$method_name);
			if (!$r) return false;
			if (!$r->isStatic()) return false;
			return true;
		}
		catch (\Exception $e) {}
		
		return false;
		
		#case ifcode JAVASCRIPT then
		
		if (typeof(class_name) == "object")
		{
			if (class_name[method_name] != undefined) return true;
			return false;
		}
		
		var obj = this.findClass(class_name);
		if (!this.exists(obj)) return false;
		if (this.exists(obj[method_name])) return true;
		return false;
	
		#endswitch
	}
	
	
	/**
	 * Create object by class_name. If class name does not exists return null
	 * @return Object
	 */
	static Object newInstance(string class_name, Collection<var> args = null)
	{
		#switch
		#case ifcode PHP then
		
		$class_name = static::find_class($class_name);
		if ($args == null)
			return new $class_name();
		$r = new \ReflectionClass($class_name);
		$arr = $args->_arr;
		return $r->newInstanceArgs($arr);
		
		#case ifcode JAVASCRIPT then
		
		var obj = this.findClass(class_name);
		if (!this.exists(obj) || !(obj instanceof Function))
		{
			throw new Runtime.Exceptions.ItemNotFound(class_name, "class name");
		}
		if (args == undefined || args == null){ args = []; }
		args = args.slice(); 
		args.unshift(null);
		var f = Function.prototype.bind.apply(obj, args);
		return new f;
		
		#endswitch
	}
	
	
	/**
	 * Return attr value by name
	 */
	static var attr(var item, string name, var def_val = null)
	{
		#switch
		#case ifcode PHP then
		return property_exists($item, $name) ? $item->$name : $def_val;
		#case ifcode JAVASCRIPT then
		return item[name] || def_val;
		#endswitch
	}
	
	
	/**
	 * Return true if value is exists
	 * @param var value
	 * @return bool
	 */
	static bool exists(var value)
	{
		#switch
		#case ifcode PHP then
		return isset($value);
		
		#case ifcode JAVASCRIPT then
		
		return (value != null) && (value != undefined);
		#endswitch
	}
	
	
	/**
	 * Return true if value is string
	 * @param var value
	 * @return bool
	 */
	static bool isString(var value)
	{
		#switch
		#case ifcode PHP then
		
		return is_string($value);
		
		#case ifcode JAVASCRIPT then
		
		if (typeof value == 'string') return true;
		else if (value instanceof String) return true;
		return false;
		
		#endswitch
	}
	
	
	/* =============================== Convert Functions ================================= */
	
	/**
	 * Convert generator to list
	 */
	static Collection list(var generator)
	{
		#ifcode JAVASCRIPT then
		return [...generator];
		#endif
		return generator;
	}
	
	
	/**
	 * Convert value to string
	 * @param var value
	 * @return string
	 */
	static string toStr(var value)
	{
		#switch
		#case ifcode PHP then
		
		$t = gettype($value);
		if ($value === null) return "";
		if (is_string($value)) return $value;
		if ($value instanceof \Runtime\StringInterface) return $value->toString();
		if (is_int($value) or is_float($value) or is_int($value))
			return (string)$value;
		if ($value === true) return "1";
		if ($value === false) return "";
		return (string)$value;
		
		#case ifcode JAVASCRIPT then
		
		var _StringInterface = use("Runtime.StringInterface");
		
		if (value === null) return "";
		if (typeof value == 'string') return value;
		if (typeof value == 'number') return ""+value;
		if (value instanceof String) return ""+value;
		if (typeof value == 'object' && this.is_implements(value, _StringInterface))
			return value.toString();
		return ""+value;
		
		#endswitch
	}
	
	
	/* ================================== IO Functions =================================== */
	
	/**
	 * Print message to output
	 */
	static void print(string message, bool new_line = true, string type="")
	{
		var output = @.provider("output");
		output.print(message, new_line, type);
	}
	
	
	/**
	 * Print error message to output
	 */
	static void print_error(string message)
	{
		var output = @.provider("output");
		output.print_error(message);
	}
	
	
	/**
	 * Color message to output
	 */
	static void color(string color, string message)
	{
		var output = @.provider("output");
		return output.color(color, message);
	}
	
	
	/**
	 * Log message
	 */
	static void log(string type, string message)
	{
		var p = @.provider("log");
		p.log(type, message);
	}
	
	
	/**
	 * Read line from input
	 */
	static void input()
	{
		var input = @.provider("input");
		return input.input();
	}
	
	
	/* ================================= Math Functions ================================== */
	
	/**
	 * Returns random value x, where 0 <= x < 1
	 * @return double
	 */
	static double urandom()
	{
		#switch
		#case ifcode PHP then
		
		return mt_rand() / (mt_getrandmax() + 1);
		
		#case ifcode JAVASCRIPT then
		
		if (
			window != undefined && window.crypto != undefined &&
			window.crypto.getRandomValues != undefined)
		{
			var s = new Uint32Array(1);
			window.crypto.getRandomValues(s);
			return s[0] / 4294967296;
		}
		
		return Math.random();
		
		#endswitch
	}
	
	
	/**
	 * Returns random value x, where a <= x <= b
	 * @param int a
	 * @param int b
	 * @return int
	 */
	static int random(int a, int b)
	{
		return static::round(static::urandom() * (b - a) + a);
	}
	
	
	/* ================================ Context Functions ================================ */
	
	protected static var _global_context = null;
	
	
	/**
	 * Returns global context
	 * @return Context
	 */
	static Context @getContext()
	{
		#switch
		#case ifcode PHP then
		if (!static::$_global_context) return null;
		return static::$_global_context;
		#case ifcode NODEJS then
		if (!rtl._global_context) return null;
		return rtl._global_context;
		#case ifcode ES6 then
		if (!Runtime.rtl._global_context) return null;
		return Runtime.rtl._global_context;
		#endswitch
	}
	
	
	/**
	 * Set global context
	 * @param Context context
	 */
	static void setContext(Context context)
	{
		#switch
		#case ifcode PHP then
		static::$_global_context = $context;
		#case ifcode JAVASCRIPT then
		use("Runtime.rtl")._global_context = context;
		#case ifcode ES6 then
		window['global_context'] = context;
		#endswitch
	}
	
	
	/**
	 * Create context
	 */
	static async Context createContext(Map params)
	{
		/* Create contenxt */
		var context = new Context(Context::initParams(params));
		
		/* Setup global context */
		static::setContext(context);
		
		#ifcode NODEJS then
		ctx = context;
		#endif
		
		/* Init context */
		await context.init();
		
		return context;
	}
}