/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.BaseObject;
use Runtime.Callback;
use Runtime.Context;
use Runtime.Date;
use Runtime.DateTime;
use Runtime.Entity.Provider;
use Runtime.Exceptions.AssertException;


class rtl
{
	/* Log level */
	
	/**
	 * Fatal error. Application stoped
	 */
	static const int LOG_FATAL = 0;
	
	/**
	 * Critical error. Application damaged, but works
	 */	
	static const int LOG_CRITICAL = 2;
	
	/**
	 * Any Application error or exception
	 */	
	static const int LOG_ERROR = 4;
	
	/**
	 * Log warning. Developer should attention to this
	 */
	static const int LOG_WARNING = 6;
	
	/**
	 * Information about any event
	 */
	static const int LOG_INFO = 8;
	
	/**
	 * Debug level 1
	 */
	static const int LOG_DEBUG = 10;
	
	/**
	 * Debug level 2
	 */	
	static const int LOG_DEBUG2 = 12;
	
	/* Status codes */ 
	static const int STATUS_PLAN = 0;
	static const int STATUS_DONE = 1;
	static const int STATUS_PROCESS = 100;
	static const int STATUS_FAIL = -1;
	
	/* Errors */
	static const int ERROR_NULL = 0;
	static const int ERROR_OK = 1;
	static const int ERROR_PROCCESS = 100;
	static const int ERROR_FALSE = -100;
	static const int ERROR_RUNTIME = -1;
	static const int ERROR_UNKNOWN = -1;
	static const int ERROR_INDEX_OUT_OF_RANGE = -2;
	static const int ERROR_STOP_ITERATION = -3;
	static const int ERROR_ITEM_NOT_FOUND = -5;
	static const int ERROR_OBJECT_ALLREADY_EXISTS = -6;
	static const int ERROR_ASSERT = -7;
	static const int ERROR_REQUEST = -8;
	static const int ERROR_RESPONSE = -9;
	static const int ERROR_CSRF_TOKEN = -10;
	static const int ERROR_VALIDATION = -12;
	static const int ERROR_SERIALIZATION = -14;
	static const int ERROR_ASSIGN = -15;
	static const int ERROR_AUTH = -16;
	static const int ERROR_DUPLICATE = -17;
	static const int ERROR_API_NOT_FOUND = -18;
	static const int ERROR_API_WRONG_FORMAT = -19;
	static const int ERROR_API_WRONG_APP_NAME = -20;
	static const int ERROR_API = -21;
	static const int ERROR_CURL = -22;
	static const int ERROR_FATAL = -99;
	static const int ERROR_HTTP_CONTINUE = -100;
	static const int ERROR_HTTP_SWITCH = -101;
	static const int ERROR_HTTP_PROCESSING = -102;
	static const int ERROR_HTTP_OK = -200;
	static const int ERROR_HTTP_BAD_GATEWAY = -502;
	static const int ERROR_USER = -10000;
	
	/* Serializer */
	static const int ALLOW_OBJECTS = 1;
	static const int JSON_PRETTY = 8;
	
	
	/**
	 * Define class
	 */
	static bool defClass(var obj)
	{
		#switch
		#case ifcode ES6 then
		if (Runtime.rtl._classes == undefined) Runtime.rtl._classes = {};
		Runtime.rtl._classes[obj.getClassName()] = obj;
		#endswitch
	}
	
	
	/**
	 * Find class instance by name. If class does not exists return null.
	 * @return var - class instance
	 */
	static var findClass(string class_name)
	{
		#switch
		#case ifcode PHP then
		return "\\" . preg_replace("/\\./", "\\", $class_name);
		
		#case ifcode JAVASCRIPT then
		
		if (typeof class_name == "string")
		{
			class_name = typeof window != "undefined" ? window[class_name] : use(class_name);
		}
		else if (class_name && !(class_name instanceof Function))
		{
			class_name = class_name.constructor;
		}
		if (class_name == undefined || class_name == null) return null;
		
		return class_name;
		
		#endswitch
	}
	
	
	/**
	 * Return class name
	 */
	static var className(var class_name)
	{
		if (static::isString(class_name)) return class_name;
		
		#switch
		#case ifcode PHP then
		
		return str_replace("\\", ".", get_class($class_name));
		
		#case ifcode JAVASCRIPT then
		
		var obj = this.findClass(class_name);
		return obj && obj.getClassName ? obj.getClassName() : "";
		
		#endswitch
	}
	
	
	/**
	 * Returns parent class name
	 */
	static var parentClassName(string class_name)
	{
		#switch
		#case ifcode PHP then
		$class_name = static::findClass($class_name);
		$class_name = get_parent_class($class_name);
		return str_replace("\\", ".", $class_name);
		#case ifcode JAVASCRIPT then
		var obj = this.findClass(class_name);
		var parentObj = obj ? Object.getPrototypeOf(obj) : null;
		return parentObj && parentObj.getClassName ? parentObj.getClassName() : "";
		#endswitch
	}
	
	
	/**
	 * Returns true if class instanceof class_name
	 * @return bool
	 */
	static bool isInstanceOf(var obj, string class_name)
	{
		if (obj == null) return false;
		
		obj = static::className(obj);
		if (not static::isString(obj)) return false;
		
		string parent_class_name = obj;
		while (parent_class_name != "")
		{
			if (parent_class_name == class_name) return true;
			parent_class_name = static::parentClassName(parent_class_name);
		}
	}
	
	
	/**
	 * Returns true if class implements interface
	 */
	static bool isImplements(var obj, string interface_name)
	{
		if (obj == null) return false;
		
		obj = static::findClass(obj);
		if (not obj) return false;
		
		while (obj != null)
		{
			if (obj.getInterfaces and obj.getInterfaces().indexOf(interface_name) >= 0) return true;
			obj = static::findClass(static::parentClassName(obj));
		}
	}
	
	
	/**
	 * Class exists
	 */
	static bool classExists(string class_name)
	{
		var obj = this.findClass(class_name);
		return obj != null;
	}
	
	
	/**
	 * Returns true if class exists
	 * @return bool
	 */
	static bool methodExists(string class_name, string method_name)
	{
		#switch
		#case ifcode PHP then
		
		if (gettype($class_name) == "object")
		{
			try
			{
				$r = new \ReflectionMethod(get_class($class_name),$method_name);
				if (!$r) return false;
				if ($r->isStatic()) return false;
				return true;
			}
			catch (\Exception $e) {}
			
			return false;
		}
		
		$class_name = static::findClass($class_name);
		if (!class_exists($class_name)) return false;
		
		try
		{
			$r = new \ReflectionMethod($class_name,$method_name);
			if (!$r) return false;
			if (!$r->isStatic()) return false;
			return true;
		}
		catch (\Exception $e) {}
		
		return false;
		
		#case ifcode JAVASCRIPT then
		
		if (typeof(class_name) == "object")
		{
			if (class_name[method_name] != undefined) return true;
			return false;
		}
		
		var obj = this.findClass(class_name);
		if (!this.exists(obj)) return false;
		if (this.exists(obj[method_name])) return true;
		return false;
	
		#endswitch
	}
	
	
	/**
	 * Create object by class_name. If class name does not exists return null
	 * @return Object
	 */
	static Object newInstance(string class_name, Collection<var> args = null)
	{
		#switch
		#case ifcode PHP then
		
		$class_name = static::findClass($class_name);
		if ($args == null)
			return new $class_name();
		$r = new \ReflectionClass($class_name);
		$arr = $args->_arr;
		return $r->newInstanceArgs($arr);
		
		#case ifcode JAVASCRIPT then
		
		var obj = this.findClass(class_name);
		if (!this.exists(obj) || !(obj instanceof Function))
		{
			throw new Runtime.Exceptions.ItemNotFound(class_name, "class name");
		}
		if (args == undefined || args == null){ args = []; }
		args = args.slice(); 
		args.unshift(null);
		var f = Function.prototype.bind.apply(obj, args);
		return new f;
		
		#endswitch
	}
	
	
	/**
	 * Return attr value by name
	 */
	static var attr(var item, string name, var def_val = null)
	{
		#switch
		#case ifcode PHP then
		return property_exists($item, $name) ? $item->$name : $def_val;
		#case ifcode JAVASCRIPT then
		return item[name] || def_val;
		#endswitch
	}
	
	
	/**
	 * Set attr to item
	 */
	static var setAttr(var item, string name, var value)
	{
		#switch
		#case ifcode PHP then
		if (property_exists($item, $name))
		{
			$item->$name = $value;
		}
		#case ifcode JAVASCRIPT then
		item[name] = value;
		#endswitch
	}
	
	
	/**
	 * Return true if value is exists
	 * @param var value
	 * @return bool
	 */
	static bool exists(var value)
	{
		#switch
		#case ifcode PHP then
		return isset($value);
		
		#case ifcode JAVASCRIPT then
		
		return (value != null) && (value != undefined);
		#endswitch
	}
	
	
	/**
	 * Returns true if value is string
	 * @param var value
	 * @return bool
	 */
	static bool isString(var value)
	{
		#switch
		#case ifcode PHP then
		
		return is_string($value);
		
		#case ifcode JAVASCRIPT then
		
		if (typeof value == 'string') return true;
		else if (value instanceof String) return true;
		return false;
		
		#endswitch
	}
	
	
	/**
	 * Returns true if object
	 */
	static bool isObject(var value)
	{
		#switch
		#case ifcode PHP then
		if (is_object($value)) return $value instanceof \Runtime\BaseObject;
		return false;
		#case ifcode JAVASCRIPT then
		return value instanceof use("Runtime.BaseObject");
		#endswitch
	}
	
	
	/**
	 * Returns true if value is collection
	 */
	static bool isCollection(var value)
	{
		#switch
		#case ifcode PHP then
		
		return $value instanceof \Runtime\Collection;
		
		#case ifcode JAVASCRIPT then
		
		return Array.isArray(value);
		
		#endswitch
	}
	
	
	/**
	 * Returns true if value is map
	 */
	static bool isMap(var value)
	{
		#switch
		#case ifcode PHP then
		
		return $value instanceof \Runtime\Map;
		
		#case ifcode JAVASCRIPT then
		
		return value instanceof Map;
		
		#endswitch
	}
	
	
	/**
	 * Translate
	 */
	static string translate(string s, Dict params)
	{
		return @.translate(s, params);
	}
	
	
	/* ================================= Lib Functions =================================== */
	
	static fn compare(string order, fn f = null)
	{
		return int (var a, var b) use (order, f)
		{
			if (f)
			{
				a = f(a);
				b = f(b);
			}
			if (a < b) return 1;
			if (a > b) return -1;
			return 0;
		};
	}
	
	/* =============================== Convert Functions ================================= */
	
	/**
	 * Convert generator to list
	 */
	static Collection list(var generator)
	{
		#switch
		#case ifcode PHP then
		return \Runtime\Vector::create(iterator_to_array($generator));
		#case ifcode JAVASCRIPT then
		const Vector = this.findClass("Runtime.Vector");
		return new Vector(...generator);
		#endswitch
		return generator;
	}
	
	
	/**
	 * Convert to int
	 */
	static int toInt(string s)
	{
		#switch
		#case ifcode PHP then
		return (int)$s;
		#case ifcode JAVASCRIPT then
		return Number(s);
		#endswitch
	}
	
	
	/**
	 * Convert value to string
	 * @param var value
	 * @return string
	 */
	static string toStr(var value)
	{
		#switch
		#case ifcode PHP then
		
		$t = gettype($value);
		if ($value === null) return "";
		if (is_string($value)) return $value;
		if ($value instanceof \Runtime\StringInterface) return $value->toString();
		if (is_int($value) or is_float($value) or is_int($value))
			return (string)$value;
		if ($value === true) return "1";
		if ($value === false) return "";
		return (string)$value;
		
		#case ifcode JAVASCRIPT then
		
		var StringInterface = use("Runtime.StringInterface");
		
		if (value === null) return "";
		if (typeof value == 'string') return value;
		if (typeof value == 'number') return ""+value;
		if (value instanceof String) return ""+value;
		if (typeof value == 'object' && this.isImplements(value, StringInterface))
			return value.toString();
		return ""+value;
		
		#endswitch
	}
	
	
	/**
	 * Convert primitive to object
	 */
	static var toNative(var obj)
	{
		#switch
		#case ifcode PHP then
		#case ifcode JAVASCRIPT then
		const RuntimeMap = this.findClass("Runtime.Map");
		const RuntimeVector = this.findClass("Runtime.Vector");
		if (obj instanceof RuntimeVector)
		{
			return obj.map((value) => { return this.toNative(value); });
		}
		else if (obj instanceof RuntimeMap)
		{
			return obj.map((value) => { return this.toNative(value); }).toObject();
		}
		return obj;
		#endswitch
	}
	
	
	/**
	 * Convert native to primitive
	 */
	static var fromNative(var obj)
	{
		#switch
		#case ifcode PHP then
		#case ifcode JAVASCRIPT then
		if (obj === null || obj === undefined)
		{
			return null;
		}
		if (Array.isArray(obj))
		{
			const RuntimeVector = this.findClass("Runtime.Vector");
			return RuntimeVector.create(obj.map(item => this.fromNative(item)));
		}
		if (typeof obj == "object")
		{
			const RuntimeMap = this.findClass("Runtime.Map");
			return RuntimeMap.create(obj).map(item => this.fromNative(item));
		}
		return obj;
		#endswitch
	}
	
	
	/**
	 * Json Decode
	 */
	static var jsonDecode(var obj)
	{
		#switch
		#case ifcode PHP then
		return json_decode($obj);
		#case ifcode JAVASCRIPT then
		try
		{
			const RuntimeVector = this.findClass("Runtime.Vector");
			const RuntimeMap = this.findClass("Runtime.Map");
			obj = JSON.parse(obj, (key, value) => {
				if (value === null) return null;
				if (Array.isArray(value)) return RuntimeVector.create(value);
				if (typeof value == "object") return RuntimeMap.create(value);
				return value;
			});
		}
		catch (e){}
		return obj;
		#endswitch
	}
	
	
	/**
	 * Json encode
	 */
	static var jsonEncode(var obj)
	{
		#switch
		#case ifcode PHP then
		return json_encode($obj);
		#case ifcode JAVASCRIPT then
		return JSON.stringify(obj);
		#endswitch
	}
	
	
	/* ================================== IO Functions =================================== */
	
	/**
	 * Print message to output
	 */
	static void print(string message, bool new_line = true, string type="")
	{
		var output = @.provider("output");
		output.print(message, new_line, type);
	}
	
	
	/**
	 * Print error message to output
	 */
	static void error(string message)
	{
		var output = @.provider("output");
		output.error(message);
	}
	
	
	/**
	 * Color message to output
	 */
	static void color(string color, string message)
	{
		var output = @.provider("output");
		return output.color(color, message);
	}
	
	
	/**
	 * Log message
	 */
	static void log(string type, string message)
	{
		var p = @.provider("log");
		p.log(type, message);
	}
	
	
	/**
	 * Read line from input
	 */
	static void input()
	{
		var input = @.provider("input");
		return input.input();
	}
	
	
	/* ================================= Math Functions ================================== */
	
	/**
	 * Returns random value x, where 0 <= x < 1
	 * @return double
	 */
	static double urandom()
	{
		#switch
		#case ifcode PHP then
		
		return mt_rand() / (mt_getrandmax() + 1);
		
		#case ifcode JAVASCRIPT then
		
		if (
			window != undefined && window.crypto != undefined &&
			window.crypto.getRandomValues != undefined)
		{
			var s = new Uint32Array(1);
			window.crypto.getRandomValues(s);
			return s[0] / 4294967296;
		}
		
		return Math.random();
		
		#endswitch
	}
	
	
	/**
	 * Returns random value x, where a <= x <= b
	 * @param int a
	 * @param int b
	 * @return int
	 */
	static int random(int a, int b)
	{
		return static::round(static::urandom() * (b - a) + a);
	}
	
	
	/* ================================ Context Functions ================================ */
	
	protected static var _global_context = null;
	
	
	/**
	 * Returns global context
	 * @return Context
	 */
	static Context getContext()
	{
		#switch
		#case ifcode PHP then
		if (!static::$_global_context) return null;
		return static::$_global_context;
		#case ifcode JAVASCRIPT then
		if (!Runtime.rtl._global_context) return null;
		return Runtime.rtl._global_context;
		#endswitch
	}
	
	
	/**
	 * Set global context
	 * @param Context context
	 */
	static void setContext(Context context)
	{
		#switch
		#case ifcode PHP then
		static::$_global_context = $context;
		#case ifcode NODEJS then
		use("Runtime.rtl")._global_context = context;
		#case ifcode ES6 then
		this._global_context = context;
		window['global_context'] = context;
		#endswitch
	}
	
	
	/**
	 * Create context
	 */
	static async Context createContext(Map params)
	{
		/* Create contenxt */
		var context = new Context(Context::initParams(params));
		
		/* Setup global context */
		static::setContext(context);
		
		/* Init context */
		await context.init(params);
		return context;
	}
	
	
	/**
	 * Create app
	 */
	static async Context createApp(string app, Collection modules)
	{
		Dict params = {
			"providers": [
				new Provider("app", app),
			],
			"modules": modules,
		};
		Context context = await this.createContext(params);
		await context.start();
		return context;
	}
	
	
	/**
	 * Run app
	 */
	static async int runApp(string app, Collection modules)
	{
		try
		{
			Context context = await static::createApp(app, modules);
			var provider = context.provider("app");
			return await provider.main();
		}
		catch (var e)
		{
			#switch
			#case ifcode PHP then
			throw $e;
			#case ifcode ES6 then
			console.log("\x1B[0;31m" + e.stack + "\x1B[0m\n");
			#case ifcode NODEJS then
			process.stderr.write("\x1B[0;91m");
			process.stderr.write(e.stack);
			process.stderr.write("\x1B[0m\n");
			#endswitch
		}
	}
	
	
	/**
	 * Mount app
	 */
	static async void mount(var app_data, string element, fn callback=null)
	{
		app_data = static::fromNative(app_data);
		
		/* Create context */
		var modules = app_data.get("modules");
		var context = await static::createContext({
			"modules": modules,
		});
		
		/* Render app */
		var render = context.factory("render");
		var result = render.mount(app_data, element);
		if (callback)
		{
			callback(result);
		}
	}
	
	
	/* ================================= Other Functions ================================= */
	
	async static void wait(int timeout)
	{
		#ifcode JAVASCRIPT then
		return new Promise((resolve, reject) => {
			setTimeout(()=>{ resolve(); }, timeout);
		});
		#endif
	}
}

#ifcode ES6 then
window["use"] = Runtime.rtl.findClass;
#endif