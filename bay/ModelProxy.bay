/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Reference;
use Runtime.Exceptions.FileNotFound;
use Runtime.Exceptions.RuntimeException;


class ModelProxy<T> extends BaseObject
{
	var container = null;
	Collection path = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(BaseObject container, Collection path = null)
	{
		parent();
        
        if (container instanceof BaseStruct)
        {
            this.container = new Reference(container);
            this.path = ["ref"].concat(path);
        }
        else
        {
		    this.container = container;
		    this.path = path;
        }
	}
	
    
    /**
     * Returns path
     */
    Collection<string> getPath() => this.path ? this.path : [];
    
	
	/**
	 * Returns model data by path
	 */
	T data() => rtl::attr(this.container, this.getPath());
	var attr(Collection path = null) => rtl::attr(this.container, this.getPath().concat(path));
	
	
	/**
	 * Set model attr
	 */
	void setAttr(Collection path, var new_data)
	{
		if (rtl::isString(path)) path = [ path ];
		BaseStruct old_model = this.data();
		BaseStruct new_model = rtl::setAttr(old_model, path, new_data);
		this.setNewModel(new_model);
	}
	
	
	/**
	 * Set new model
	 */
	void setNewModel(var new_model)
	{
		BaseStruct old_model = this.data();
		this.container = rtl::setAttr(this.container, this.getPath(), new_model);
        
        if (rtl::method_exists(this.container, "onUpdateModel"))
        {
		    this.container.onUpdateModel(this.getPath(), old_model, new_model);
        }
	}
	
	
	/**
	 * Commit model
	 */
	var commit(string method_name)
	{
		Collection<string> args = null;
		BaseStruct old_model = this.data();
		BaseStruct new_model = null;
		
		#switch
		#case ifcode PHP then
		$args = \Runtime\Collection::from(func_get_args())->slice(1);
		#case ifcode ES6 then
		args = Runtime.Collection.from( [ ...arguments ].slice(1) );
		#endswitch
		
		if (old_model == null)
		{
			throw new RuntimeException("model is null");
		}
		
		string class_name = old_model::getClassName();
		
		if ( rtl::method_exists(old_model, method_name) )
		{
			fn f = rtl::method(old_model, method_name);
			new_model = rtl::apply(f, args);
		}
		elseif ( rtl::method_exists(class_name, method_name) )
		{
			fn f = rtl::method(class_name, method_name);
			args = args.prependIm(old_model);
			new_model = rtl::apply(f, args);
		}
		else
		{
			throw new FileNotFound(class_name ~ "::" ~ method_name, "Method");
		}
		
		this.setNewModel(new_model);
	}
	
	
	/**
	 * Commit model
	 */
	var commitAsync(string method_name)
	{
		Collection<string> args = null;
		BaseStruct model = this.data();
		string class_name = model::getClassName();
		
		#switch
		#case ifcode PHP then
		$args = \Runtime\Collection::from(func_get_args())->slice(1);
		#case ifcode ES6 then
		args = Runtime.Collection.from( [ ...arguments ].slice(1) );
		#endswitch
		
		if ( rtl::method_exists(class_name, method_name) )
		{
			fn f = rtl::method(class_name, method_name);
			args = args.prependIm(this);
			await rtl::applyAsync(f, args);
		}
		else
		{
			throw new FileNotFound(class_name ~ "::" ~ method_name, "Method");
		}
	}
	
	
	/**
	 * Commit model
	 */
	ModelProxy proxy(Collection path)
	{
		if (rtl::isString(path)) path = [ path ];
		return new ModelProxy(this.container, this.getPath().concat(path));
	}
}