/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellRtl.Lib;



export class rtl{
	
	protected static var _global_context = null;
	
	
	/**
	 * Returns global context
	 * @return ContextInterface
	 */
	public static ContextInterface globalContext(){
		return self::_global_context;
	}
	
	
	
	/**
	 * Set global context
	 * @param ContextInterface context
	 */
	public static ContextInterface setGlobalContext(ContextInterface context){
		self::_global_context = context;
		return context;
	}
	
	
	
	#switch
	#case ifcode JAVASCRIPT then
	static implements(obj, interface_name){
		if (obj == undefined) return false;
		if (obj.__implements__ == undefined) return false;
		return obj.__implements__.indexOf(interface_name) != -1;
	}
	#endswitch
	
	
	
	/**
	 * Find class instance by name. If class does not exists return null.
	 * @return var - class instance
	 */
	declare export static var find_class(var class_name);
	
	
	#switch
	#case ifcode ES6 then
	static find_class(class_name){
		if (class_name instanceof Function)
			return class_name;
		
		var arr = class_name.split('.');
		var obj = window;
		
		for (var i=0; i<arr.length; i++){
			var key = arr[i];
			if (obj[key] == undefined)
				return false;
			obj = obj[key];
		}
		
		return obj;
	}
	#case ifcode NODEJS then
	static find_class(class_name){
		if (class_name instanceof Function)
			return class_name;
		
		var class_name_arr = class_name.split('.');
		if (class_name_arr.length < 2)
			return null;
		
		var module_name = class_name_arr[0];
		var last_name = class_name_arr[ class_name_arr.length - 1 ];
		
		var obj = require(module_name);
		for (var i=1; i<class_name_arr.length - 1; i++){
			if (!this.exists(obj[class_name_arr[i]])){
				obj = null;
				break;
			}
			obj = obj[ class_name_arr[i] ];
		}
		
		if (!this.exists(obj))
			return null;
		
		obj = obj[last_name];
		return obj;
	}
	#endswitch
	
	
	
	
	/**
	 * Create object by class_name. If class name does not exists return null
	 * @return Object
	 */
	declare export static Object Instance(string class_name, array args);

	#switch
	#case ifcode PHP then
	static function Instance($class_name){
		return new $class_name();
	}
	#case ifcode JAVASCRIPT then
	static Instance(class_name, args){
		var obj = this.find_class(class_name);
		if (!this.exists(obj)) return null;
		if (!(obj instanceof Function)) return null;
		if (args == undefined) args = [];
		args = args.slice(); 
		args.unshift(null);
		var f = Function.prototype.bind.apply(obj, args);
		return new f;
	}
	#endswitch
	
	
	
	/**
	 * Call method
	 * @return Object
	 */
	declare export static var callMethod(Object obj, string method_name, Vector args);
	
	#switch
	#case ifcode PHP then
	static function callMethod($obj, $method_name, $args){
		return call_user_func_array([$obj, $method_name], $args);
	}
	#case ifcode JAVASCRIPT then
	static callMethod(obj, method_name, args){
		var f = obj[method_name];
		return f.apply(obj, args);
	}
	#endswitch
	
	
	
	/**
	 * Call method
	 * @return Object
	 */
	declare export static var callStaticMethod(string class_name, string method_name, Vector args = null);
	
	#switch
	#case ifcode PHP then
	static function callStaticMethod($class_name, $method_name, $args){
		return call_user_func_array([$class_name, $method_name], $args);
	}
	#case ifcode JAVASCRIPT then
	static callStaticMethod(class_name, method_name, args){
		var obj = this.find_class(class_name);
		var f = obj[method_name];
		return f.apply(obj, args);
	}
	#endswitch
	
	
	
	/**
	 * Clone var
	 * @param {var} value - Variable
	 * @return {var} result
	 */
	declare static var clone(var value, ContextInterface context = null);
	
	
	#switch
	#case ifcode JAVASCRIPT then
	static clone(val, context){
		
		if (val == null)
			return null;
		
		else if (val instanceof Number){
			return new Number(val);
		}
		else if (val instanceof String){
			return new String(val);
		}
		else if (val instanceof Boolean){
			return new Boolean(val);
		}
		else if (val instanceof Date){
			return new Date(val);
		}
		else if (Array.isArray(val)){	
			var res = [];
			for (var i=0;i<val.length;i++){
				res[i] = this.clone(val[i]);
			}
			return res;
		}
		else if (typeof val == 'object'){
			var res = {};
			
			if (val.nodeType && typeof val.cloneNode == "function"){
				return val.cloneNode(true);
			}
			else if (typeof val.clone == "function"){
				return val.clone( context );
			}
			else if (val.prototype){
				res = new item.constructor();
			}
			
			for (var i in val){
				res[i] = this.clone(val[i]);
			}
			
			return res;
		}
	}
	#endswitch
	
	
	
	/**
	 * Return true if value is exists
	 * @param var value
	 * @return boolean
	 */
	declare export static boolean exists(var value);

	#switch
	#case ifcode PHP then
	static function exists(&$value){ 
		return isset($value);
	}
	#case ifcode JAVASCRIPT then
	static exists(value){
		return (value != null) && (value != undefined);
	}
	#endswitch
	
	
	
	/**
	 * Returns true if value is scalar value
	 * @return boolean 
	 */
	static bool isScalarValue(var value){
		if (rtl::isString(value)) return true;
		return false;
	}
	
	
	
	/**
	 * Return true if value is string
	 * @param var value
	 * @return boolean
	 */
	declare export static boolean isString(var value);

	#switch
	#case ifcode PHP then
	static function isString($value){
		return is_string($value);
	}
	#case ifcode JAVASCRIPT then
	static isString(value){
		if (typeof value == 'string') return true;
		else if (value instanceof String) return true;
		return false;
	}
	#endswitch
	
	
	
	/**
	 * Convert value to string
	 * @param var value
	 * @return string
	 */
	declare export static string toString(var value);

	#switch
	#case ifcode PHP then
	static function toString($value){
		return (string)$value;
	}
	#case ifcode JAVASCRIPT then
	static toString(value){
		if (typeof value == 'string') return value;
		if (value instanceof String) return value;
		return new String(value);
	}
	#endswitch
	
	
	
	/**
	 * Convert value to int
	 * @param var value
	 * @return string
	 */
	declare export static int toInt(var val);

	#switch
	#case ifcode PHP then
	static function toInt($val){
		return (int)$val;
	}
	#case ifcode JAVASCRIPT then
	static toInt(val){
		return parseInt(val);
	}
	#endswitch
	
}