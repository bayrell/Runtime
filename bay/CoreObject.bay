/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.rtl;
use Runtime.Map;
use Runtime.Vector;


class CoreObject
{
	
	protected bool _is_destroyed = false;	
	
	
	/** 
	 * Constructor
	 */
	public void constructor()
	{
		#switch
		#case ifcode PHP then
		$this->_init();
		#case ifcode JAVASCRIPT then
		this._init();
		#endswitch
	}
	
	
	
	#switch
	#case ifcode PHP then
	protected function _init(){}
	#case ifcode JAVASCRIPT then
	_init(){
		this.__implements__ = new Array();
	}
	#endswitch
	
	
	
	#switch
	#case ifcode JAVASCRIPT then
	_del(){
	}
	#case ifcode PHP then
	function __destruct() {
		/*this._is_destroyed = true;*/
	}
	#endswitch
	
	
	
	/**
	 * Returns instance of the value by variable name
	 * @param string variable_name
	 * @param string default_value
	 * @return var
	 */
	public var takeValue(string variable_name, var default_value = null)
	{
		return this.takeVirtualValue(variable_name, default_value);
	}
	
	
	
	/**
	 * Returns virtual values
	 * @param string variable_name
	 * @param string default_value
	 * @return var
	 */
	void takeVirtualValue(string variable_name, var default_value = null)
	{
		return default_value;
	}
	
	
	
	/**
	 * Assign and clone data from other object
	 * @param CoreObject obj
	 */
	void assignObject(CoreObject obj)
	{
	}
	
	
		
	/**
	 * Set new value instance by variable name
	 * @param string variable_name
	 * @param var value
	 */
	public void assignValue(string variable_name, var value)
	{
	}
	
	
	
	/**
	 * Set new values instance by Map
	 * @param Map<mixed> map
	 * @return CoreObject
	 */
	public CoreObject assignMap(Map<mixed> values = null)
	{
		if (values == null)
			return;
		Vector<string> names = new Vector();
		this.getVariablesNames(names, 2);
		names.each(
			void (string name) use (values)
			{
				this.assignValue(name, values.get(name, null));
			}
		);
		delete names;
		return this;
	}
	
	
	
	/**
	 * Set new values instance by Map
	 * @param Map<mixed> map
	 * @return CoreObject
	 */
	public CoreObject setMap(Map<mixed> values = null)
	{
		if (values == null)
			return;
		
		values.each(
			void (string key, mixed value)
			{
				this.assignValue(key, value);
			}
		);
		
		return this;
	}
	
	
	
	/**
	 * Dump serializable object to Map
	 * @return Map<mixed>
	 */
	public Map<mixed> takeMap(int flag=2)
	{
		Map<mixed> values = new Map();
		Vector<string> names = new Vector();
		this.getVariablesNames(names, flag);
		names.each(
			void (string name) use (values)
			{
				values.set(name, this.takeValue(name, null));
			}
		);
		return values;
	}
	
	
	
	/**
	 * Call static method of the current class
	 * @param string method_name
	 * @param Vector args
	 * @return mixed
	 */
	public mixed callStaticMethod(string method_name, Vector args = null)
	{
		return rtl::callStaticMethod(this.getClassName(), method_name, args);
	}
	
	
	
	/**
	 * Returns field info by field_name
	 * @param string field_name
	 * @return IntrospectionInfo
	 */
	public static IntrospectionInfo getFieldInfoByName(string field_name)
	{
	}
	
	
	
	/**
	 * Returns virtual field info by field_name
	 * @param string field_name
	 * @return IntrospectionInfo
	 */
	public static IntrospectionInfo getVirtualFieldInfo(string field_name)
	{
		return null;
	}
	
	
	
	/**
	 * Returns public fields list
	 * @param Vector<string> names
	 */
	public static void getFieldsList(Vector<string> names, int flag=0)
	{
	}
	
	
	
	/**
	 * Returns public virtual fields names
	 * @param Vector<string> names
	 */
	public static void getVirtualFieldsList(Vector<string> names, int flag=0)
	{
	}
	
	
	
	/**
	 * Returns info of the public method by name
	 * @param string method_name
	 * @return IntrospectionInfo
	 */
	public static IntrospectionInfo getMethodInfoByName(string method_name)
	{
		return null;
	}
	
	
	
	/**
	 * Returns list of the public methods
	 * @param Vector<string> methods
	 */
	public static void getMethodsList(Vector<string> methods)
	{
	}
	
	
	
	/**
	 * Returns names of variables to serialization
	 * @param Vector<string>
	 */
	public void getVariablesNames(Vector<string> names, int flag=0)
	{
		rtl::callStaticMethod
		(
			"Runtime.RuntimeUtils", "getVariablesNames",
			[this.getClassName(), names, flag]
		);
	}
	
	
	
	
	/**
	 * Returns info of the public variable by name
	 * @param string variable_name
	 * @return IntrospectionInfo
	 */
	public void getFieldInfo(string variable_name)
	{
		Vector<string> classes = rtl::callStaticMethod
		(
			"Runtime.RuntimeUtils", "getParents",
			[ this.getClassName() ]
		);
		
		for (int i=0; i<classes.count(); i++)
		{
			string class_name = classes.item(i);
			IntrospectionInfo info = rtl::callStaticMethod(class_name, "getFieldInfoByName", [variable_name]);
			if (info != null  and item.kind == IntrospectionInfo::ITEM_FIELD)
				return info;
			try
			{ 
				IntrospectionInfo info = rtl::callStaticMethod(class_name, "getVirtualFieldInfo", [variable_name]); 
				if (info != null  and item.kind == IntrospectionInfo::ITEM_FIELD)
					return info;
			} 
			catch (var e) {}
		}
		return null;
	}
	
	
	
	/**
	 * Returns names of methods
	 * @param Vector<string>
	 */
	public void getMethodsNames(Vector<string> names)
	{
		Vector<string> classes = rtl::callStaticMethod
		(
			"Runtime.RuntimeUtils", "getParents",
			[ this.getClassName() ]
		);
		
		for (int i=0; i<classes.count(); i++)
		{
			string class_name = classes.item(i);
			rtl::callStaticMethod(class_name, "getMethodsList", [names]);
		}
	}
	
	
	
	/**
	 * Returns info of the public method by name
	 * @param string method_name
	 * @return IntrospectionInfo
	 */
	public IntrospectionInfo getMethodInfo(string method_name)
	{
		Vector<string> classes = rtl::callStaticMethod
		(
			"Runtime.RuntimeUtils", "getParents",
			[ this.getClassName() ]
		);
		
		for (int i=0; i<classes.count(); i++)
		{
			string class_name = classes.item(i);
			IntrospectionInfo info = rtl::callStaticMethod(class_name, "getMethodInfoByName", [method_name]);
			if (info != null and item.kind == IntrospectionInfo::ITEM_METHOD)
				return info;
		}
		return null;
	}
	
	
}