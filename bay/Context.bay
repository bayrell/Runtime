/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.rs;
use Runtime.rtl;
use Runtime.CoreObject;
use Runtime.CoreProvider;
use Runtime.LambdaChain;
use Runtime.Provider;
use Runtime.Dict;
use Runtime.Map;
use Runtime.Vector;
use Runtime.RuntimeConstant;
use Runtime.Exceptions.RuntimeException;
use Runtime.Interfaces.ContextInterface;
use Runtime.Interfaces.FactoryInterface;
use Runtime.Interfaces.ModuleDescriptionInterface;


class Context extends CoreObject implements ContextInterface
{
	protected string base_path = null;
	protected Dict<mixed> config = null;
	protected Vector<Provider> _modules = null;
	protected Vector<CoreStruct> _entities = null;
	protected Map<mixed> _drivers = null;
	protected Map<string> _providers = null;
	protected Map<mixed> _providers_obj = null;
	
	
	/**
	 * Constructor
	 */
	void constructor()
	{
		parent();
		this._entities = new Vector<CoreStruct>();
		this._modules = new Vector<string>();
		this._providers = new Map<string>();
		this._providers_obj = new Map<mixed>();
	}
	
	
	
	/**
	 * Destructor
	 */
	public void destructor()
	{
		delete this._providers;
		delete this._providers_obj;
		delete this._entities;
		delete this._modules;
		parent();
	}
	
	
	
	/**
	 * Returns registed modules
	 * @return Vector<string>
	 */
	Collection<string> getModules()
	{
		return this._modules.toCollection();
	}
	
	
	
	/**
	 * Returns providers names
	 */
	Collection<string> getProviders()
	{
		return this._providers.keys().toCollection();
	}
	
	
	
	/**
	 * Create provider
	 *
	 * @params string provider_name
	 * @return CoreProvider
	 */
	public CoreProvider createProvider(string class_name, Dict params = null)
	{
		if (params == null)
		{
			if (this._providers_obj.has(class_name))
			{
				params = this._providers_obj.item(class_name);
			}
			else
			{
				params = (method (class_name, "getDefaultProviderData"))(this);
				this._providers_obj.set(class_name, params);
			}
		}
		
		CoreProvider provider = rtl::newInstance(class_name, [ params ]);
		provider = this.chain(class_name, [this, provider]);
		return provider;
	}
	
	
	
	/**
	 * Returns provider
	 *
	 * @params string provider_name
	 * @return CoreProvider
	 */
	public CoreProvider getProvider(string provider_name, Dict params = null)
	{
		CoreProvider provider = null;
		if (this._providers.has(provider_name))
		{
			Provider info = this._providers.item(provider_name);
			string class_name = info.value;
			if (class_name == "") class_name = info.name;
			provider = this.createProvider(class_name, params);
			if (provider_name != class_name) obj = this.chain(provider_name, [this, provider]);
		}
		else
		{
			provider = this.createProvider(provider_name, params);
			obj = this.chain(provider_name, [this, provider]);
		}
		return provider;
	}
	
	
	
	/**
	 * Register module
	 */
	ContextInterface registerModule(string module_name)
	{
		if (this._modules.indexOf(module_name) != -1)
			return;
		
		string module_description_class_name = module_name ~ ".ModuleDescription";
		if (not rtl::class_exists(module_description_class_name))
		{
			throw new RuntimeException("Module " ~ module_name ~ " not found", RuntimeConstant::ERROR_FILE_NOT_FOUND);
		}
		
		/* Add module */
		this._modules.push(module_name);
		
		/* Register required Modules*/
		fun f = rtl::method(module_description_class_name, "requiredModules");
		Dict<string> modules = f();
		
		if (modules != null)
		{
			Vector<string> keys = modules.keys();
			int sz = keys.count();
			for (int i=0; i<sz; i++)
			{
				string module_name = keys.item(i);
				module_name = rs::replace("/", ".", module_name);
				this.registerModule(module_name);
			}
			delete keys;
			delete modules;
		}
		
		/* Call entities */
		fun f = rtl::method(module_description_class_name, "entities");
		Collection<CoreStruct> entities = f([ this ]);
		if (entities != null)
		{
			this._entities = this._entities.appendVector(entities);
		}
		
		/* Call onRegister */
		fun f = rtl::method(module_description_class_name, "onRegister");
		Collection<CoreStruct> entities = f([ this ]);
		
		return this;
	}
	
	
	
	/**
	 * Apply Lambda Chain
	 */
	CoreStruct chain(string chain_name, Dict args)
	{
		Collection<CoreStruct> entities = this._entities.filter
		(
			bool (CoreStruct item) use (chain_name) => 
				item instanceof LambdaChain and 
				item.name == chain_name and 
				item.is_async == false
		);
		entities = entities.sortIm
		(
			int (LambdaChain a, LambdaChain b) => a.pos > b.pos
		);
		
		for (int i=0; i<entities.count(); i++)
		{
			LambdaChain item = entities.item(i);
			string item_chain_name = item.chain;
			if (item_chain_name != "")
			{
				mixed res = this.chain(item_chain_name, args);
				args = args.setIm( args.count() - 1, res);
			}
			else
			{
				Collection arr = rs::split("::", item.value);
				string class_name = arr.get(0, "");
				string method_name = arr.get(1, "");
				fun f = rtl::method(class_name, method_name);
				mixed res = rtl::apply(f, args);
				args = args.setIm( args.count() - 1, res);
			}
		}
		mixed res = args.last();
		return res;
	}
	
	
	
	/**
	 * Apply Lambda Chain Await
	 */
	async CoreStruct chainAwait(string chain_name, Dict args)
	{
		Collection<CoreStruct> entities = this._entities.filter
		(
			bool (CoreStruct item) use (chain_name) => 
				item instanceof LambdaChain and 
				item.name == chain_name
		);
		entities = entities.sortIm
		(
			int (LambdaChain a, LambdaChain b) => a.pos > b.pos
		);
		
		mixed obj = args.last();
		for (int i=0; i<entities.count(); i++)
		{
			LambdaChain item = entities.item(i);
			string item_chain_name = item.chain;
			if (item_chain_name != "")
			{
				mixed res = await this.chainAwait(item_chain_name, args);
				args = args.setIm( args.count() - 1, res);
			}
			else
			{
				Collection arr = rs::split("::", item.value);
				string class_name = arr.get(0, "");
				string method_name = arr.get(1, "");
				fun f = rtl::method(class_name, method_name);
				
				if (item.is_async)
				{
					mixed res = await rtl::apply(f, args);
					args = args.setIm( args.count() - 1, res);
				}
				else
				{
					mixed res = rtl::apply(f, args);
					args = args.setIm( args.count() - 1, res);
				}
			}
		}
		mixed res = args.last();
		return res;
	}
	
	
	
	/**
	 * Read config
	 */
	ContextInterface readConfig(Dict<mixed> config)
	{
		this.config = config;
		
		/* Set base path */
		mixed runtime = config.get("Runtime", null);
		if (runtime != null and runtime instanceof Dict)
		{
			mixed base_path = runtime.get("base_path", null, "string");
			if (base_path != null)
			{
				this.base_path = base_path;
			}
		}
		
		return this;
		
		Vector<var> args = new Vector();
		args.push(this);	
		args.push(config);	
		
		int sz = this._modules.count();
		for (int i=0; i<sz; i++)
		{
			string module_name = this._modules.item(i);
			string module_description_class_name = module_name ~ ".ModuleDescription";
			rtl::callStaticMethod(
				module_description_class_name, 
				"onReadConfig",
				args
			);
		}
				
		delete args;
		
		return this;
	}
	
	
	
	Dict<mixed> getConfig()
	{
		return this.config;
	}
	
	
	Dict<mixed> getConfigItem
	(
		Collection<scalar> path, mixed default_value, string type_value = "mixed", string type_template = ""
	)
	{
		return RuntimeUtils::getItem(this.config, path, default_value, type_value, type_template);
	}
	
	
	/**
	 * Init context
	 */
	ContextInterface init()
	{
		/* Register providers */
		Collection<CoreStruct> providers = this._entities.filter
		(
			bool (CoreStruct item) => item instanceof Provider
		);
		for (int i=0; i<providers.count(); i++)
		{
			Provider item = providers.item(i);
			this._providers.set(item.name, item);
		}
		
		/* Call onInitContext */
		Collection<mixed> args = [ this ];
		int sz = this._modules.count();
		for (int i=0; i<sz; i++)
		{
			string module_name = this._modules.item(i);
			string module_description_class_name = module_name ~ ".ModuleDescription";
			rtl::callStaticMethod(
				module_description_class_name, 
				"onInitContext",
				args
			);
		}
		
		delete args;
		
		return this;
	}
	
	
	
	/**
	 * Set application locale
	 * @params string locale
	 */
	void setLocale(string locale)
	{
		this._values.set("default.locale", locale);
	}
	
	
	
	/**
	 * Get application locale
	 * @params string locale
	 */
	string getLocale()
	{
		return this._values.get("default.locale", "en", "string");
	}
	
	
	
	/**
	 * Translate message
	 * @params string message - message need to be translated
	 * @params Map params - Messages params. Default null.
	 * @params string locale - Different locale. Default "".
	 * @return string - translated string
	 */
	string translate(string message, Map params = null, string locale = ""){
		return message;
	}
	
	
	
	/**
	 * Fork current context
	 * @return ContextInterface
	 */
	ContextInterface fork()
	{
		string class_name = this.getClassName();
		ContextInterface obj = rtl::newInstance(class_name);
		
		/* Add modules */
		this._modules.each( 
			void (string item) use (obj)
			{
				obj._modules.push(item);
			}
		);
		
		/* Add services */
		this._drivers.each( 
			void (string key, mixed value) use (obj)
			{
				obj._drivers.set(key, value);
			}
		);
		
		/* Add provider names */
		this._providers_names.each( 
			void (string key, FactoryInterface value) use (obj)
			{
				obj._providers_names.set(key, value);
			}
		);
		
		/* Add values */
		this._values.each( 
			void (string key, mixed value) use (obj)
			{
				obj._values.set(key, value);
			}
		);
		
		return obj;
	}
	
	
	
	/**
	 * Realease context resources
	 */
	void release(){}
	
	
	
	/**
	 * Returns base path
	 * @return string
	 */
	string getBasePath()
	{
		return this.base_path;
	}
	
	
	
	/**
	 * Local bus call
	 * @param string class_name
	 * @param string method_name
	 * @param ApiRequest request
	 * @return mixed The result of the api
	 */ 
	async ApiResult bus(
		string class_name, string interface_name, string method_name, 
		Map<mixed> data
	)
	{
		BusInterface provider = this.getProvider("Runtime.Interfaces.BusInterface");
		ApiResult res = await provider.call(this, class_name, interface_name, method_name, data);
		return res;
	}
	
}