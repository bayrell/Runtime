/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.lib;
use Runtime.BaseObject;
use Runtime.BaseProvider;
use Runtime.BaseStruct;
use Runtime.Provider;
use Runtime.Exceptions.RuntimeException;
use Runtime.Hooks.AppHook;


struct Context extends BaseStruct
{
	/* Struct data */
	var app = null;
	string base_path = "";
	string entry_point = "";
	Collection<string> cli_args = [];
	Dict<string> environments = {};
	Collection<string> modules = [];
	Dict<BaseObject> providers = {};
	Collection<BaseStruct> entities = [];
	Dict<var> settings = {};
	int start_time = 0;
	string tz = "UTC";
	bool initialized = false;
	
		
	/**
	 * Returns modules entities
	 */
	pure Collection<BaseStruct> getEntitiesFromModules(Collection<string> modules)
	{
		Vector<BaseStruct> entities = new Vector();
		for (int i=0; i<modules.count(); i++)
		{
			string module_class_name = modules.item(i) ~ ".ModuleDescription";
			if (rtl::method_exists(module_class_name, "entities"))
			{
				fn f = rtl::method(module_class_name, "entities");
				Collection<BaseStruct> arr = f();
				entities.appendVector(arr);
			}
		}
		return entities.removeDuplicates().toCollection();
	}
	
	
	
	/**
	 * Add provider
	 */
	Context addProvider(string provider_name, BaseProvider provider)
	{
		Context c = this;
		
		if (this.providers.has(provider_name))
		{
			throw new RuntimeException("Provider + '" + provider_name + "' already registered");
		}
		if (not(provider instanceof BaseProvider))
		{
			throw new RuntimeException("Provider + '" + provider_name +
				"' must be intstanceof BaseProvider");
		}
		
		c <= providers <= c.providers.setIm(provider_name, provider);
		
		return c;
	}
	
	
	
	/**
	 * Returns provider by name
	 */
	BaseObject provider(string provider_name)
	{
		if (not this.providers.has(provider_name))
		{
			throw new RuntimeException("Provider + '" + provider_name + "' not found");
		}
		return this.providers.get(provider_name);
	}
	
	
	
	/**
	 * Return environment
	 */
	var env(string name)
	{
		var value = this.environments[name];
		
		Dict hook_res = this.callHook(AppHook::ENV, {
			"name": name,
			"value": value,
		});
		
		return hook_res["value"];
	}
	
	
	
	/**
	 * Create context
	 */
	static void create(Dict d)
	{
		if (not (d instanceof Dict))
		{
			d = Dict::@from(d);
		}
		
		#switch
		
		#case ifcode PHP then
		
		
		#case ifcode JAVASCRIPT then
		
		if (!d.has(ctx, "start_time"))
		{
			d = d.setIm(ctx, "start_time", Date.now());
		}
		
		#case ifcode NODEJS then
		
		let Collection = use("Runtime.Collection");
		let Dict = use("Runtime.Dict");
		
		if (!d.has(ctx, "cli_args"))
		{
			d = d.setIm(ctx, "cli_args", Collection.from(process.argv.slice(1)));
		}
		if (!d.has(ctx, "base_path"))
		{
			d = d.setIm(ctx, "base_path", process.cwd());
		}
		if (!d.has(ctx, "environments"))
		{
			d = d.setIm(ctx, "environments", Dict.from(process.env));
		}
		
		#endswitch
		
		if (d.has("modules"))
		{
			var modules = d.get("modules");
			if (not(modules instanceof Collection))
			{
				d <= modules <= Collection::@from(modules);
			}
		}
		
		Context instance = rtl::newInstance(static::getClassName(), [ d ]);
		
		return instance;
	}
	
	
	
	/**
	 * Init
	 */
	async Context init()
	{
		var hook_res;
		
		Context c = this;
		
		if (c.initialized) return c;
		
		/* Get modules */
		Collection<string> modules = c.modules;
		if (modules.indexOf("Runtime"))
		{
			modules = modules.prependIm("Runtime");
		}
		
		/* Get modules entities */
		Collection<BaseStruct> entities = static::getEntitiesFromModules(modules);
		c <= entities <= entities;
		
		/* Create providers */
		Collection<Provider> providers = c.entities.filter( lib::isInstance(classof Provider) );
		for (int i=0; i<providers.count(); i++)
		{
			Provider info = providers[i];
			if (info.value)
			{
				BaseProvider provider = rtl::newInstance(info.value);
				c = c.addProvider(info.name, provider);
			}
		}
		
		/* Create app */
		if (this.entry_point != "")
		{
			c <= app <= rtl::newInstance(this.entry_point);
		}
		
		/* Init hooks */
		/*
		var hook = c.provider("hook");
		if (hook)
		{
			await hook.init();
		}
		*/
		
		/* Init providers */
		Collection<string> providers_names = this.providers.keys();
		for (int i=0; i<providers_names.count(); i++)
		{
			string provider_name = providers_names[i];
			BaseProvider provider = this.providers[provider_name];
			c = await provider.init(c);
		}
		
		/* Hook init app */
		hook_res = await c.callAsyncHook(AppHook::INIT, { "context": c });
		c = hook_res["context"];
		
		/* Init app */
		if (c.app != null and rtl::method_exists(c.app, "init"))
		{
			c = await c.app.init(c);
		}
		
		/* Set initialized */
		c <= initialized <= true;
		
		return c;
	}
	
	
	
	/**
	 * Run context
	 */
	async int run()
	{
		int code = 0;
		
		/* Start providers */
		Collection<string> providers_names = this.providers.keys();
		for (int i=0; i<providers_names.count(); i++)
		{
			string provider_name = providers_names[i];
			BaseProvider provider = this.providers[provider_name];
			if (not provider.started)
			{
				await provider.start();
			}
		}
		
		/* Run app */
		if (this.app == null)
			return;
		
		/* Hook start app */
		await this.callAsyncHook(AppHook::START, {});
		
		/* Start app */
		if (rtl::method_exists(this.app, "start"))
		{
			await this.app.start();
		}
		
		/* Run entry_point */
		if (rtl::method_exists(this.app, "main"))
		{
			code = await this.app.main();
		}
		
		return code;
	}
	
	
	
	/**
	 * Call hook
	 */
	Dict callHook(string hook_name, Dict d)
	{
		return d;
	}
	
	
	
	/**
	 * Call async hook
	 */
	async Dict callAsyncHook(string hook_name, Dict d)
	{
		return d;
	}
	
	
}
