/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.lib;
use Runtime.BaseObject;
use Runtime.BaseProvider;
use Runtime.Callback;
use Runtime.Entity.Entity;
use Runtime.Entity.Provider;
use Runtime.Exceptions.ItemNotFound;
use Runtime.Exceptions.RuntimeException;
use Runtime.Hooks.RuntimeHook;


class Context extends BaseObject
{
	protected Dict<string> environments = {};
	protected Dict<BaseObject> providers = {};
	protected Collection<string> modules = [];
	protected Collection<BaseObject> entities = [];
	protected string base_path = "";
	protected int start_time = 0;
	protected bool initialized = false;
	protected bool started = false;
	
	
	/**
	 * Returns true if is initialized
	 */
	bool isInitialized() => this.initialized;
	
	
	/**
	 * Returns true if is started
	 */
	bool isStarted() => this.started;
	
	
	/**
	 * Returns start time
	 */
	int getStartTime() => this.start_time;
	
	
	/**
	 * Returns base path
	 */
	var getBasePath() => this.base_path;
	
	
	/**
	 * Returns entities
	 */
	Vector<string> getEntities(string class_name = "")
	{
		if (class_name == "")
		{
			return this.entities.slice();
		}
		return this.entities.filter(
			bool (string entity_name) use (class_name) => rtl::isInstanceOf(entity_name, class_name)
		);
	}
	
	
	/**
	 * Returns environments
	 */
	Dict<string> getEnvironments() => this.environments.copy();
	
	
	/**
	 * Returns provider by name
	 */
	BaseObject provider(string provider_name)
	{
		if (not this.providers.has(provider_name))
		{
			throw new ItemNotFound(provider_name, "Provider");
		}
		return this.providers.get(provider_name);
	}
	
	
	/**
	 * Return environment
	 */
	var env(string name)
	{
		var value = this.environments.get(name);
		Dict res = { "name": name, "value": value };
		this.hook(RuntimeHook::ENV, res);
		return res.get("value");
	}
	
	
	/**
	 * Init params
	 */
	static void initParams(Dict params)
	{
		#switch
		#case ifcode PHP then
		#case ifcode JAVASCRIPT then
		
		if (!params.has("start_time"))
		{
			params.set("start_time", Date.now());
		}
		
		#case ifcode NODEJS then
		
		if (!params.has("cli_args"))
		{
			params.set("cli_args", process.argv.slice(1));
		}
		if (!params.has("base_path"))
		{
			params.set("base_path", process.cwd());
		}
		if (!params.has("environments"))
		{
			params.set("environments", Map.from(process.env));
		}
		
		#endswitch
		
		/* Setup default environments */
		if (not params.has("environments")) params.set("environments", new Map());
		
		Dict env = params.get("environments");
		if (not env.has("CLOUD_ENV")) env.set("CLOUD_ENV", false);
		if (not env.has("DEBUG")) env.set("DEBUG", false);
		if (not env.has("LOCALE")) env.set("LOCALE", "en_US");
		if (not env.has("TZ")) env.set("TZ", "UTC");
		if (not env.has("TZ_OFFSET")) env.set("TZ_OFFSET", 0);
		
		return params;
	}
	
	
	/**
	 * Constructor
	 */
	void constructor(Dict params)
	{
		parent();
		if (params.has("base_path")) this.base_path = params.get("base_path");
		if (params.has("cli_args")) this.cli_args = params.get("cli_args");
		if (params.has("environments")) this.environments = params.get("environments");
		if (params.has("modules")) this.modules = params.get("modules");
		if (params.has("start_time")) this.start_time = params.get("start_time");
	}
	
	
	/**
	 * Init
	 */
	async void init(Dict params)
	{
		if (this.initialized) return;
		
		/* Extend modules */
		this.modules = static::getRequiredModules(this.modules);
		
		/* Get modules entities */
		this.entities = static::getEntitiesFromModules(this.modules);
		
		/* Create providers */
		Collection<Provider> providers = this.getEntities(classof Provider);
		this.createProviders(providers);
		
		/* Create providers from params */
		if (params.has("providers"))
		{
			this.createProviders(params.get("providers"));
		}
		
		/* Init providers */
		await this.initProviders();
		
		/* Hook init app */
		await this.hook(RuntimeHook::INIT);
		
		/* Set initialized */
		this.initialized = true;
	}
	
	
	/**
	 * Start context
	 */
	async void start()
	{
		if (this.started) return;
		
		/* Start providers */
		await this.startProviders();
		
		/* Hook start app */
		await this.hook(RuntimeHook::START);
		
		/* Set started */
		this.started = true;
	}
	
	
	/**
	 * Run context
	 */
	async int run()
	{
		return 0;
	}
	
	
	/**
	 * Create providers
	 */
	protected void createProviders(Collection<Provider> providers)
	{
		for (int i=0; i<providers.count(); i++)
		{
			Provider factory = providers.get(i);
			
			/* Create provider */
			BaseProvider provider = factory.createInstance();
			if (not provider)
			{
				throw new RuntimeException("Can't to create provider '" ~ factory.name ~ "'");
			}
			
			/* Add provider */
			this.registerProvider(factory.name, provider);
		}
	}
	
	
	/**
	 * Register provider
	 */
	void registerProvider(string provider_name, BaseProvider provider)
	{
		if (this.initialized) return;
		
		if (not(provider instanceof BaseProvider))
		{
			throw new RuntimeException("Provider '" + provider_name +
				"' must be intstanceof BaseProvider");
		}
		
		this.providers.set(provider_name, provider);
	}
	
	
	/**
	 * Init providers
	 */
	protected async void initProviders()
	{
		Vector<string> providers_names = rtl::list(this.providers.keys());
		for (int i=0; i<providers_names.count(); i++)
		{
			string provider_name = providers_names.get(i);
			BaseProvider provider = this.providers.get(provider_name);
			await provider.init();
		}
	}
	
	
	/**
	 * Start providers
	 */
	protected async void startProviders()
	{
		Vector<string> providers_names = rtl::list(this.providers.keys());
		for (int i=0; i<providers_names.count(); i++)
		{
			string provider_name = providers_names.get(i);
			BaseProvider provider = this.providers.get(provider_name);
			await provider.start();
		}
	}
	
	
	/**
	 * Call hook
	 */
	Map hook(string hook_name, Map params = null)
	{
		var hook = this.provider("hook");
		return hook.apply(hook_name, params);
	}
	
	
	/**
	 * Translate message
	 */
	string translate(string s, Dict params = null)
	{
		if (params == null) return s;
		return rs::format(s, params);
	}
	
	
	/**
	 * Returns all modules
	 * @param Collection<string> modules
	 * @return Collection<string>
	 */
	static Vector<string> getRequiredModules(Collection<string> modules)
	{
		Vector<string> res = new Vector();
		Map<string> cache = new Map();
		static::_getRequiredModules(res, cache, modules);
		return res.removeDuplicates();
	}
	
	
	/**
	 * Returns required modules
	 * @param string class_name
	 * @return Collection<string>
	 */
	static void _getRequiredModules
	(
		Vector<string> res,
		Map<string> cache,
		Collection<string> modules
	)
	{
		if (modules == null) return;
		for (int i=0; i<modules.count(); i++)
		{
			string module_name = modules.get(i);
			if (not cache.has(module_name))
			{
				cache.set(module_name, true);
				Callback f = new Callback(module_name ~ ".ModuleDescription", "requiredModules");
				if (f.exists())
				{
					Map<string> sub_modules = f.apply();
					if (sub_modules != null)
					{
						Vector<string> sub_modules = rtl::list(sub_modules.keys());
						static::_getRequiredModules(res, cache, sub_modules);
					}
					res.push(module_name);
				}
			}
		}
	}
	
	
	/**
	 * Returns modules entities
	 */
	static Collection<Entity> getEntitiesFromModules(Collection<string> modules)
	{
		return modules.reduce(
			void (Collection entities, string module_name)
			{
				Callback f = new Callback(module_name ~ ".ModuleDescription", "entities");
				if (!f.exists()) return entities;
				Vector<Entity> arr = f.apply();
				if (!arr) return entities;
				return entities.concat(arr);
			},
			new Vector()
		);
	}
}