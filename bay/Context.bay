/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.rs;
use Runtime.rtl;
use Runtime.CoreObject;
use Runtime.CoreProvider;
use Runtime.Dict;
use Runtime.Map;
use Runtime.Vector;
use Runtime.RuntimeConstant;
use Runtime.Annotations.Manager;
use Runtime.Annotations.LambdaChain;
use Runtime.Annotations.Provider;
use Runtime.Exceptions.RuntimeException;
use Runtime.Interfaces.ContextInterface;
use Runtime.Interfaces.FactoryInterface;
use Runtime.Interfaces.ModuleDescriptionInterface;


class Context extends CoreObject implements ContextInterface
{
	protected string base_path = null;
	protected Dict<mixed> config = null;
	protected Vector<string> _modules = null;
	protected Vector<string> _modules_cache = null;
	protected Vector<CoreStruct> _entities = null;
	protected Map<Manager> _managers = null;
	protected Map<Provider> _providers = null;
	protected Map<mixed> _managers_obj = null;
	protected Map<mixed> _providers_obj = null;
	
	
	/**
	 * Constructor
	 */
	void constructor()
	{
		parent();
		this._entities = new Vector<CoreStruct>();
		this._modules = new Vector<string>();
		this._modules_cache = new Vector<string>();
		this._managers = new Map<Manager>();
		this._providers = new Map<Provider>();
		this._managers_obj = new Map<mixed>();
		this._providers_obj = new Map<mixed>();
	}
	
	
	
	/**
	 * Destructor
	 */
	public void destructor()
	{
		delete this._managers;
		delete this._providers;
		delete this._providers_obj;
		delete this._entities;
		delete this._modules;
		delete this._modules_cache;
		parent();
	}
	
	
	
	/**
	 * Returns base path
	 * @return string
	 */
	string getBasePath()
	{
		return this.base_path;
	}
	
	
	
	/**
	 * Returns registed modules
	 * @return Vector<string>
	 */
	Collection<string> getModules()
	{
		return this._modules.toCollection();
	}
	
	
	
	/**
	 * Create manager
	 *
	 * @params string manager_name
	 * @return CoreManager
	 */
	public CoreManager getManager(string manager_name)
	{
		if (this._managers_obj.has(manager_name))
		{
			return this._managers_obj.item(manager_name);
		}
		
		CoreManager manager = null;
		if (this._managers.has(manager_name))
		{
			Manager info = this._managers.item(manager_name);
			string class_name = info.value;
			if (class_name == "") class_name = info.name;
			
			manager = rtl::newInstance(class_name);
			manager = this.chain(class_name, [this, manager]);
			
			if (manager_name != class_name) manager = this.chain(manager_name, [this, manager]);
		}
		else
		{
			manager = rtl::newInstance(manager_name, [ this ]);
			manager = this.chain(manager_name, [this, manager]);
		}
		
		manager.flushModel();
		this._managers_obj.set(manager_name, manager);
		return manager;
	}
	
	
	
	/**
	 * Create provider
	 *
	 * @params string provider_name
	 * @return CoreProvider
	 */
	protected CoreProvider createProvider(string class_name, Dict params = null)
	{
		if (params == null)
		{
			if (this._providers_obj.has(class_name))
			{
				params = this._providers_obj.item(class_name);
			}
			else
			{
				params = (method (class_name, "getDefaultProviderData"))(this);
				this._providers_obj.set(class_name, params);
			}
		}
		
		CoreProvider provider = rtl::newInstance(class_name, [ params ]);
		provider = this.chain(class_name, [this, provider]);
		
		return provider;
	}
	
	
	
	/**
	 * Returns provider
	 *
	 * @params string provider_name
	 * @return CoreProvider
	 */
	public CoreProvider getProvider(string provider_name, Dict params = null)
	{
		CoreProvider provider = null;
		if (this._providers.has(provider_name))
		{
			Provider info = this._providers.item(provider_name);
			string class_name = info.value;
			if (class_name == "") class_name = info.name;
			provider = this.createProvider(class_name, params);
			if (provider_name != class_name) provider = this.chain(provider_name, [this, provider]);
		}
		else
		{
			provider = this.createProvider(provider_name, params);
		}
		return provider;
	}
	
	
	
	/**
	 * Register module
	 */
	ContextInterface registerModule(string module_name, bool recursive = true)
	{
		if (this._modules.indexOf(module_name) != -1) return;
		if (this._modules_cache.indexOf(module_name) != -1) return;
		
		string module_description_class_name = module_name ~ ".ModuleDescription";
		if (not rtl::class_exists(module_description_class_name))
		{
			throw new RuntimeException("Module " ~ module_name ~ " not found", RuntimeConstant::ERROR_FILE_NOT_FOUND);
		}
		
		/* Add module */
		this._modules_cache.push(module_name);
		
		/* Register required Modules*/
		if (recursive)
		{
			fun f = rtl::method(module_description_class_name, "requiredModules");
			Dict<string> modules = f();
			
			if (modules != null)
			{
				Vector<string> keys = modules.keys();
				int sz = keys.count();
				for (int i=0; i<sz; i++)
				{
					string m_name = keys.item(i);
					m_name = rs::replace("/", ".", m_name);
					this.registerModule(m_name);
				}
				delete keys;
				delete modules;
			}
		}
		
		/* Add module */
		this._modules.push(module_name);
		
		/* Call entities */
		fun f = rtl::method(module_description_class_name, "entities");
		Collection<CoreStruct> entities = f([ this ]);
		if (entities != null)
		{
			this._entities = this._entities.appendVector(entities);
		}
		
		/* Call onRegister */
		fun f = rtl::method(module_description_class_name, "onRegister");
		Collection<CoreStruct> entities = f([ this ]);
		
		return this;
	}
	
	
	
	/**
	 * Register global Context
	 */
	ContextInterface registerModules(Collection<string> modules = null, bool recursive = true)
	{
		if (modules == null) return this;
		modules.each( void (string module) use (recursive) => this.registerModule(module, recursive) );
		return this;
	}
	
	
	
	/**
	 * Apply Lambda Chain
	 */
	CoreStruct chain(string chain_name, Dict args)
	{
		Collection<CoreStruct> entities = this._entities.filter
		(
			bool (CoreStruct item) use (chain_name) => 
				item instanceof LambdaChain and 
				item.name == chain_name and 
				item.is_async == false
		);
		entities = entities.sortIm
		(
			int (LambdaChain a, LambdaChain b) => a.pos > b.pos
		);
		
		for (int i=0; i<entities.count(); i++)
		{
			LambdaChain item = entities.item(i);
			string item_chain_name = item.chain;
			if (item_chain_name != "")
			{
				mixed res = this.chain(item_chain_name, args);
				args = args.setIm( args.count() - 1, res);
			}
			else
			{
				Collection arr = rs::split("::", item.value);
				string class_name = arr.get(0, "");
				string method_name = arr.get(1, "");
				fun f = rtl::method(class_name, method_name);
				mixed res = rtl::apply(f, args);
				args = args.setIm( args.count() - 1, res);
			}
		}
		mixed res = args.last();
		return res;
	}
	
	
	
	/**
	 * Apply Lambda Chain Await
	 */
	async CoreStruct chainAwait(string chain_name, Dict args)
	{
		Collection<CoreStruct> entities = this._entities.filter
		(
			bool (CoreStruct item) use (chain_name) => 
				item instanceof LambdaChain and 
				item.name == chain_name
		);
		entities = entities.sortIm
		(
			int (LambdaChain a, LambdaChain b) => a.pos > b.pos
		);
		
		mixed obj = args.last();
		for (int i=0; i<entities.count(); i++)
		{
			LambdaChain item = entities.item(i);
			string item_chain_name = item.chain;
			if (item_chain_name != "")
			{
				mixed res = await this.chainAwait(item_chain_name, args);
				args = args.setIm( args.count() - 1, res);
			}
			else
			{
				Collection arr = rs::split("::", item.value);
				string class_name = arr.get(0, "");
				string method_name = arr.get(1, "");
				fun f = rtl::method(class_name, method_name);
				
				if (item.is_async)
				{
					mixed res = await rtl::apply(f, args);
					args = args.setIm( args.count() - 1, res);
				}
				else
				{
					mixed res = rtl::apply(f, args);
					args = args.setIm( args.count() - 1, res);
				}
			}
		}
		mixed res = args.last();
		return res;
	}
	
	
	
	/**
	 * Read config
	 */
	ContextInterface readConfig(Dict<mixed> config)
	{
		this.config = config;
		
		/* Set base path */
		mixed runtime = config.get("Runtime", null);
		if (runtime != null and runtime instanceof Dict)
		{
			mixed base_path = runtime.get("base_path", null, "string");
			if (base_path != null)
			{
				this.base_path = base_path;
			}
		}
		
		return this;
	}
	
	
	
	/**
	 * Returns config
	 */
	Dict<mixed> getConfig()
	{
		return this.config;
	}
	
	
	
	/**
	 * Returns config item
	 */
	Dict<mixed> getConfigItem
	(
		Collection<scalar> path, mixed default_value, string type_value = "mixed", string type_template = ""
	)
	{
		return RuntimeUtils::getItem(this.config, path, default_value, type_value, type_template);
	}
	
	
	
	/**
	 * Init context
	 */
	void init()
	{
		/* Register providers */
		Collection<CoreStruct> providers = this._entities.filter
		(
			bool (CoreStruct item) => item instanceof Provider
		);
		for (int i=0; i<providers.count(); i++)
		{
			Provider item = providers.item(i);
			this._providers.set(item.name, item);
		}
		
		/* Register managers */
		Collection<CoreStruct> managers = this._entities.filter
		(
			bool (CoreStruct item) => item instanceof Manager
		);
		for (int i=0; i<managers.count(); i++)
		{
			Manager item = managers.item(i);
			this._managers.set(item.name, item);
		}
		
		/* Call onInitContext */
		Collection<mixed> args = [ this ];
		int sz = this._modules.count();
		for (int i=0; i<sz; i++)
		{
			string module_name = this._modules.item(i);
			string module_description_class_name = module_name ~ ".ModuleDescription";
			rtl::callStaticMethod
			(
				module_description_class_name, 
				"onInitContext",
				args
			);
		}
		
		delete args;
		
		return this;
	}
	
	
	
	/**
	 * Start context
	 */
	async void start()
	{
		Collection<string> managers = this._managers.keys();
		for (int i=0; i<managers.count(); i++)
		{
			string manager_name = managers.item(i);
			CoreManager manager = this.getManager(manager_name);
			await manager.startManager();
		}
	}
	
	
	
	/**
	 * Translate message
	 * @params string message - message need to be translated
	 * @params Map params - Messages params. Default null.
	 * @params string locale - Different locale. Default "".
	 * @return string - translated string
	 */
	string translate(string message, Map params = null, string locale = "")
	{
		return message;
	}
	
	
	
	/**
	 * Local bus call
	 * @param string class_name
	 * @param string method_name
	 * @param ApiRequest request
	 * @return mixed The result of the api
	 */ 
	async ApiResult busCall(
		string class_name, string interface_name, string method_name, 
		Collection<primitive> data
	)
	{
		BusInterface provider = this.getProvider("Runtime.Interfaces.BusInterface");
		ApiResult res = await provider.call(this, class_name, interface_name, method_name, data);
		return res;
	}
	
	
	
	/**
	 * Remote bus call
	 * @param string remote_name
	 * @param string method_name
	 * @param ApiRequest request
	 * @return mixed The result of the api
	 */ 
	async ApiResult remoteBusCall
	(
		string remote_gate,
		string class_name, string interface_name, string method_name, 
		Collection<primitive> data
	)
	{
		RemoteBusInterface provider = this.getProvider("Runtime.Interfaces.RemoteBusInterface");
		provider = provider.setRemoteGate(remote_gate);
		ApiResult res = await provider.call(this, class_name, interface_name, method_name, data);
		return res;
	}
	
}