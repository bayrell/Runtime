/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.lib;
use Runtime.BaseObject;
use Runtime.BaseProvider;
use Runtime.BaseStruct;
use Runtime.Callback;
use Runtime.Entity.Provider;
use Runtime.Exceptions.RuntimeException;
use Runtime.Hooks.RuntimeHook;


class Context extends BaseObject
{
	/* Struct data */
	protected var app = null;
	protected string base_path = "";
	protected string entry_point = "";
	protected Vector<string> start_modules = [];
	protected Vector<string> cli_args = [];
	protected Map<string> environments = {};
	protected Vector<string> modules = [];
	protected Map<BaseObject> providers = {};
	protected Vector<BaseStruct> entities = [];
	protected int start_time = 0;
	protected string tz = "UTC";
	protected bool initialized = false;
	
	
	/**
	 * Returns provider by name
	 */
	BaseObject provider(string provider_name)
	{
		if (not this.providers.has(provider_name))
		{
			throw new RuntimeException("Provider '" ~ provider_name ~ "' not found");
		}
		return this.providers.get(provider_name);
	}
	
	
	/**
	 * Return environment
	 */
	var env(string name)
	{
		var value = this.environments[name];
		
		Map hook_res = this.callHook(RuntimeHook::ENV, {
			"name": name,
			"value": value,
		});
		
		return hook_res["value"];
	}
	
	
	/**
	 * Create context
	 */
	static Context create(Dict params)
	{
		if (not (params instanceof Dict))
		{
			params = Dict::@from(params);
		}
		
		params = params.toMap();
		
		#switch
		
		#case ifcode PHP then
		
		
		#case ifcode JAVASCRIPT then
		
		if (!params.has("start_time"))
		{
			params.set("start_time", Date.now());
		}
		
		#case ifcode NODEJS then
		
		let Collection = use("Runtime.Collection");
		let Dict = use("Runtime.Dict");
		let Map = use("Runtime.Map");
		
		if (!params.has("cli_args"))
		{
			params.set("cli_args", Collection.from(process.argv.slice(1)));
		}
		if (!d.has("base_path"))
		{
			params.set("cli_args", process.cwd());
		}
		if (!d.has("environments"))
		{
			params.set("cli_args", Map.from(process.env));
		}
		
		#endswitch
		
		if (params.has("modules"))
		{
			var modules = params.get("modules");
			if (not(modules instanceof Collection))
			{
				modules = Collection::@from(modules);
			}
			params.set("modules", modules.toVector());
		}
		
		/* Setup default environments */
		if (not params.has("environments")) params.set("environments", new Map());
		
		Map env = params["environments"];
		if (not env.has("DEBUG")) env.set("DEBUG", false);
		if (not env.has("LOCALE")) env.set("LOCALE", "en_US");
		if (not env.has("LOCALE_CODE")) env.set("LOCALE_CODE", "en");
		
		Context instance = rtl::newInstance(static::getClassName(), [params]);
		return instance;
	}
	
	
	/**
	 * Init
	 */
	async Context init()
	{
	}
	
	
	/**
	 * Start context
	 */
	async void start()
	{
	}
	
	
	/**
	 * Run context
	 */
	async int run()
	{
		int code = 0;
		
		/* Run app */
		if (this.app == null)
			return;
		
		/* Run entry_point */
		if (rtl::method_exists(this.app, "main"))
		{
			/* Hook launched app */
			await this.callAsyncHook(RuntimeHook::RUN, {});
			
			code = await this.app.main();
		}
		
		return code;
	}
	
	
	/**
	 * Call hook
	 */
	Map callHook(string hook_name, Map d)
	{
		var hook = this.provider("hook");
		Collection<Callback> methods_list = hook.getMethods(hook_name);
		
		for (int i=0; i<methods_list.count(); i++)
		{
			Callback f = methods_list[i];
			d = rtl::apply(f, [d]);
			if (rtl::isPromise(d))
			{
				throw new RuntimeException("Promise is not allowed");
			}
		}
		
		return d;
	}
	
	
	/**
	 * Call hook
	 */
	async Map callHookAsync(string hook_name, Map d)
	{
		var hook = this.provider("hook");
		Collection<Callback> methods_list = hook.getMethods(hook_name);
		
		for (int i=0; i<methods_list.count(); i++)
		{
			Callback f = methods_list[i];
			d = await rtl::apply(f, [d]);
		}
		
		return d;
	}
	
	
	/**
	 * Translate message
	 */
	string translate(string module, string s, Dict params = null)
	{
		if (params == null) return s;
		return this.format(s, params);
	}
	
}