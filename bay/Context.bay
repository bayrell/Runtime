/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime;

use Runtime.rs;
use Runtime.rtl;
use Runtime.CoreObject;
use Runtime.LambdaChain;
use Runtime.Provider;
use Runtime.RuntimeUtils;
use Runtime.Map;
use Runtime.Vector;
use Runtime.Interfaces.ContextInterface;
use Runtime.Interfaces.FactoryInterface;
use Runtime.Interfaces.ModuleDescriptionInterface;


class Context extends CoreObject implements ContextInterface
{
	protected string base_path = null;
	protected Dict<mixed> config = null;
	protected Vector<Provider> _modules = null;
	protected Vector<CoreStruct> _entities = null;
	protected Map<mixed> _drivers = null;
	protected Map<string> _providers = null;
	protected Map<mixed> _providers_obj = null;
	
	
	/**
	 * Constructor
	 */
	void constructor()
	{
		parent();
		this._entities = new Vector<CoreStruct>();
		this._modules = new Vector<string>();
		this._providers = new Map<string>();
		this._providers_obj = new Map<mixed>();
	}
	
	
	
	/**
	 * Destructor
	 */
	public void destructor()
	{
		delete this._providers;
		delete this._providers_obj;
		delete this._entities;
		delete this._modules;
		parent();
	}
	
	
	
	/**
	 * Returns registed modules
	 * @return Vector<string>
	 */
	Collection<string> getModules()
	{
		return this._modules.toCollection();
	}
	
	
	
	/**
	 * Returns providers names
	 */
	Collection<string> getProviders()
	{
		return this._providers.keys().toCollection();
	}
	
	
	
	/**
	 * Returns helper
	 *
	 * @params string provider_name
	 * @return CoreStruct
	 */
	public CoreStruct createProvider(string provider_name)
	{
		if (this._providers.has(provider_name))
		{
			Provider info = this._providers.item(provider_name);
			CoreStruct obj = rtl::newInstance(info.value);
			if (info.init)
			{
				
				fun f = info.init;
				obj = f(this, obj);
			}
			else
			{
				fun f = rtl::method(info.value, "init");
				obj = f(this, obj);
			}
			obj = this.chain(info.value, obj);
			return obj;
		}
		return null;
	}
	
	
	
	/**
	 * Returns helper
	 *
	 * @params string provider_name
	 * @return CoreStruct
	 */
	public CoreStruct getProvider(string provider_name)
	{
		if (this._providers_obj.has(provider_name))
		{
			return this._providers_obj.item(provider_name);
		}		
		if (this._providers.has(provider_name))
		{
			mixed provider = this.createProvider(provider_name);
			this._providers_obj.set(provider_name, provider);
			return provider;
		}
		return null;
	}
	
	
	
	/**
	 * Register module
	 */
	ContextInterface registerModule(string module_name)
	{
		if (this._modules.indexOf(module_name) != -1)
			return;
		
		string module_description_class_name = module_name ~ ".ModuleDescription";
		if (not rtl::class_exists(module_description_class_name))
		{
			return this;
		}
		
		/* Add module */
		this._modules.push(module_name);
		
		/* Register required Modules*/
		Map<string> modules = rtl::callStaticMethod(
			module_description_class_name, 
			"requiredModules",
			[]
		);
		if (modules != null)
		{
			Vector<string> keys = modules.keys();
			int sz = keys.count();
			for (int i=0; i<sz; i++)
			{
				string module_name = keys.item(i);
				this.registerModule(module_name);
			}
			delete keys;
			delete modules;
		}
		
		/* Call entities */
		Collection<CoreStruct> entities = rtl::callStaticMethod(
			module_description_class_name, 
			"entities",
			[this]
		);
		if (entities != null)
		{
			this._entities = this._entities.appendVector(entities);
		}
		
		/* Call onRegister */
		rtl::callStaticMethod(
			module_description_class_name, 
			"onRegister",
			[this]
		);
		
		return this;
	}
	
	
	
	/**
	 * Apply Lambda Chain
	 */
	CoreStruct chain(string filter_name, CoreStruct obj = null)
	{
		Collection<CoreStruct> entities = this._entities.filter
		(
			bool (CoreStruct item) => item instanceof LambdaChain
		);
		entities = entities.filter
		( 
			bool (LambdaChain item) use (filter_name) => item.name == filter_name
		);
		entities = entities.sortIm
		(
			int (LambdaChain a, LambdaChain b) => a.pos > b.pos
		);
		for (int i=0; i<entities.count(); i++)
		{
			LambdaChain item = entities.item(i);
			callback f = item.value;
			obj = f(this, obj);
		}
		return obj;
	}
	
	
	
	/**
	 * Read config
	 */
	ContextInterface readConfig(Dict<mixed> config)
	{
		this.config = config;
		
		/* Set base path */
		mixed base_path = RuntimeUtils::getItem(config, ["Runtime", "base_path"], null, "string");
		if (base_path != null)
		{
			this.base_path = base_path;
		}
		
		return this;
		
		Vector<var> args = new Vector();
		args.push(this);	
		args.push(config);	
		
		int sz = this._modules.count();
		for (int i=0; i<sz; i++)
		{
			string module_name = this._modules.item(i);
			string module_description_class_name = module_name ~ ".ModuleDescription";
			rtl::callStaticMethod(
				module_description_class_name, 
				"onReadConfig",
				args
			);
		}
				
		delete args;
		
		return this;
	}
	
	
	
	Dict<mixed> getConfig()
	{
		return this.config;
	}
	
	
	
	/**
	 * Init context
	 */
	ContextInterface init()
	{
		/* Register providers */
		Collection<CoreStruct> providers = this._entities.filter
		(
			bool (CoreStruct item) => item instanceof Provider
		);
		for (int i=0; i<providers.count(); i++)
		{
			Provider item = providers.item(i);
			this._providers.set(item.name, item);
		}
		
		/* Call onInitContext */
		Vector<var> args = new Vector();
		args.push(this);	
	
		int sz = this._modules.count();
		for (int i=0; i<sz; i++)
		{
			string module_name = this._modules.item(i);
			string module_description_class_name = module_name ~ ".ModuleDescription";
			rtl::callStaticMethod(
				module_description_class_name, 
				"onInitContext",
				args
			);
		}
		
		delete args;
		
		return this;
	}
	
	
	
	/**
	 * Set application locale
	 * @params string locale
	 */
	void setLocale(string locale)
	{
		this._values.set("default.locale", locale);
	}
	
	
	
	/**
	 * Get application locale
	 * @params string locale
	 */
	string getLocale()
	{
		return this._values.get("default.locale", "en", "string");
	}
	
	
	
	/**
	 * Translate message
	 * @params string message - message need to be translated
	 * @params Map params - Messages params. Default null.
	 * @params string locale - Different locale. Default "".
	 * @return string - translated string
	 */
	string translate(string message, Map params = null, string locale = ""){
		return message;
	}
	
	
	
	/**
	 * Fork current context
	 * @return ContextInterface
	 */
	ContextInterface fork()
	{
		string class_name = this.getClassName();
		ContextInterface obj = rtl::newInstance(class_name);
		
		/* Add modules */
		this._modules.each( 
			void (string item) use (obj)
			{
				obj._modules.push(item);
			}
		);
		
		/* Add services */
		this._drivers.each( 
			void (string key, mixed value) use (obj)
			{
				obj._drivers.set(key, value);
			}
		);
		
		/* Add provider names */
		this._providers_names.each( 
			void (string key, FactoryInterface value) use (obj)
			{
				obj._providers_names.set(key, value);
			}
		);
		
		/* Add values */
		this._values.each( 
			void (string key, mixed value) use (obj)
			{
				obj._values.set(key, value);
			}
		);
		
		return obj;
	}
	
	
	
	/**
	 * Realease context resources
	 */
	void release(){}
	
	
	
	/**
	 * Returns base path
	 * @return string
	 */
	string getBasePath()
	{
		return this.base_path;
	}
	
	
	
	/**
	 * Call api
	 * @param string class_name
	 * @param string method_name
	 * @param ApiRequest request
	 * @return mixed The result of the api
	 */ 
	declare async ApiResult callApi(
		string class_name, string interface_name, string method_name, 
		Map<mixed> data
	);
	
	
	#switch
	#case ifcode JAVASCRIPT then
	
	callApi(class_name, interface_name, method_name, data)
	{
		var bus = this.getProvider("core.ui.bus");
		method_name = (interface_name != "") ? interface_name + "." + method_name : method_name;
		return (ctx) => {
			bus.sendApi(
				class_name,
				method_name,
				data,
				(function (ctx){
					return function (data){
						var res = new Core.Http.ApiResult( data );
						return ctx.resolve(res);
					}
				})(ctx)
			);
			return null;
		}
	}
	
	#case ifcode PHP then
	
	public function callApi($class_name, $interface_name, $method_name, $data)
	{
		$app = $this->getProvider("Core.Backend.BackendAppProvider");
		$app_class_name = $app->getClassName();
		$app_class_name = rtl::find_class($app_class_name);
		return call_user_func_array(
			[ $app_class_name, "callApi" ],
			[ $this, $app, $class_name, $interface_name, $method_name, $data ]
		);
	}
	
	#endswitch
	
}