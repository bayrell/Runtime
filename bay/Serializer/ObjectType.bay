/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.Serializer;

use Runtime.BaseObject;
use Runtime.Chain;
use Runtime.Serializer.BaseType;
use Runtime.Serializer.MapType;
use Runtime.Serializer.TypeError;
use Runtime.Serializer;
use Runtime.SerializeInterface;


class ObjectType extends MapType
{
	fn fn_create = null;
	fn fn_rules = null;
	fn fn_serialize = null;
	Chain setup = new Chain;
	string class_name = "";
	string class_extends = "";
	string class_implements = "";
	Map params = {};
	
	
	/**
	 * Create object
	 */
	void constructor(Map params = null)
	{
		parent();
		this.params = params;
		
		if (not params) return;
		if (params.has("autocreate")) this.autocreate();
		if (params.has("create")) this.fn_create = params.get("create");
		if (params.has("class_name")) this.class_name = params.get("class_name");
		if (params.has("class_extends")) this.class_extends = params.get("extends");
		if (params.has("class_implements")) this.class_implements = params.get("implements");
		if (params.has("rules")) this.fn_rules = params.get("rules");
		if (params.has("serialize")) this.fn_serialize = params.get("serialize");
	}
	
	
	/**
	 * Set class name
	 */
	void setClassName(string class_name)
	{
		this.class_name = class_name;
	}
	
	
	/**
	 * Copy object
	 */
	ObjectType copy()
	{
		ObjectType rules = new ObjectType();
		rules.fn_create = this.fn_create;
		rules.fn_rules = this.fn_rules;
		rules.fn_serialize = this.fn_serialize;
		rules.setup = this.setup;
		rules.items = this.items.map(Vector (Vector items) => items.slice());
		rules.class_name = this.class_name;
		rules.class_extends = this.class_extends;
		rules.class_implements = this.class_implements;
		return rules;
	}
	
	
	/**
	 * Autocreate
	 */
	void autocreate()
	{
		this.fn_rules = SerializeInterface(ObjectType rules, Map value)
		{
			rules.class_name = value.get("__class_name__");
		};
		this.fn_serialize = void (SerializeInterface item, Map value)
		{
			value.set("__class_name__", item::getClassName());
		};
	}
	
	
	/**
	 * Create object
	 */
	SerializeInterface createObject(Map value, Vector errors, SerializeInterface prev)
	{
		if (this.class_name == "") return null;
		if (not rtl::classExists(this.class_name))
		{
			errors.push("Class '" ~ this.class_name ~ "' does not exists");
			return null;
		}
		if (this.class_extends != "" and
			not(rtl::isInstanceOf(this.class_name, this.class_extends)))
		{
			errors.push("Class '" ~ this.class_name ~
				"' does not extends '" ~ this.class_extends ~ "'");
			return null;
		}
		if (this.class_implements != "" and
			not(rtl::isImplements(this.class_name, this.class_implements)))
		{
			errors.push("Class '" ~ this.class_name ~
				"' does not implements '" ~ this.class_implements ~ "'");
			return null;
		}
		if (this.fn_create)
		{
			fn fn_create = this.fn_create;
			return fn_create(prev, this, value);
		}
		return rtl::newInstance(this.class_name, [value]);
	}
	
	
	/**
	 * Init rules
	 */
	void initRules(Map value)
	{
		if (this.fn_rules)
		{
			fn rules = this.fn_rules;
			rules(this, value);
		}
		return this;
	}
	
	
	/**
	 * Filter value
	 */
	SerializeInterface filter(
		Map value, Vector errors, SerializeInterface old_value = null, SerializeInterface prev = null
	)
	{
		if (value == null) return null;
		
		SerializeInterface new_value = old_value;
		if (not new_value)
		{
			BaseType rules = this.copy().initRules(value);
			new_value = rules.createObject(value, errors, prev);
		}
		if (not new_value) return null;
		
		BaseType rules = new ObjectType(this.params);
		new_value::serialize(rules);
		
		rules.setup.apply([new_value, rules]);
		
		rules.walk(
			value, errors,
			void (BaseType field, var new_item, Vector item_errors, string key)
				use (value, prev, new_value)
			{
				if (not value.has(key)) return;
				var old_item = new_value ? rtl::attr(new_value, key) : null
				new_item = field.filter(new_item, item_errors, old_item, new_value);
				if (key != "__class_name__")
				{
					rtl::setAttr(new_value, key, new_item);
				}
			}
		)
		
		return new_value;
	}
	
	
	/**
	 * Returns data
	 */
	Map encode(SerializeInterface value)
	{
		if (value === null) return null;
		if (not (value implements SerializeInterface)) return null;
		
		BaseType rules = new ObjectType(this.params);
		value::serialize(rules);
		
		Vector errors = [];
		Map new_value = rules.walk(
			value, errors,
			void (BaseType field, var new_item, Vector item_errors)
			{
				return field.encode(new_item);
			}
		)
		
		fn serialize = this.fn_serialize;
		if (serialize) serialize(value, new_value);
		
		return new_value;
	}
}